<?xml version="1.0"?>
<doc>
    <assembly>
        <name>GSG.NET</name>
    </assembly>
    <members>
        <member name="T:GSG.NET.Concurrent.DistributedThread">
            <summary>
            Muti Core Thread
            </summary>
        </member>
        <member name="T:GSG.NET.Concurrent.LockUtils">
            <summary>
            <para>Lock 처리 Utility</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.LockUtils.TryLock(System.Object)">
            <summary>
            <para>arg object try lock</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.LockUtils.Lock(System.Object)">
            <summary>
            <para>arg object lock을 얻을때까지 blocking</para>
            <para>동일 Thread의 경우 Lock은 Unlock 하지 않고 2번 이상 호출이 가능하다.</para>
            <para>Unlock을 pair하지 않을 경우 Notify가 동작하지 않으며 arg object에 대해 
            Unlock을 하는 순간 Notify를 이용한 다음 동작이 수행된다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.LockUtils.Unlock(System.Object)">
            <summary>
            <para>arg object unlock</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.LockUtils.Wait">
            <summary>
            <para>무한대기</para>
            <para>0을 입력할 경우에만 false반환되며, 나머지는 true</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.LockUtils.Wait(System.Int32)">
            <summary>
            <para>Notify를 하지 않고 Wait만 하는 경우 사용.</para>
            <para>Threadsafe한 object을 생성하여 단순 대기.</para>
            <para>Notify를 이용하여 깨어나지 않으므로 항상 False 반환.</para>
            <para>-</para>
            <para>-1 or Timeout.Infinite를 넣을 경우 무한대기</para>
            <para>0일 경우 바로 return 됨</para>
            </summary>
            <param name="ms">milli-second</param>
        </member>
        <member name="M:GSG.NET.Concurrent.LockUtils.WaitK(System.Int32,System.Object)">
            <summary>
            초단위 지연, K: 1000
            <para>0보다 작으면 무한대기</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.LockUtils.WaitK(System.Int32)">
            <summary>
            초단위 지연, 기본 1초, K: 1000
            <para>0보다 작으면 무한대기</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.LockUtils.Wait100(System.Int32)">
            <summary>
            100ms 단위 지연, 기본 100ms
            <para>0보다 작으면 무한대기</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.LockUtils.Wait(System.Object)">
            <summary>
            <para>Wait를 호출하는 순간 모든 Thread의 Lock이 해제된다. => Wait와 Lock을 같은 객체로 사용하지 않는것이 좋다.</para>
            <para>Wait를 했다 하더라도 Lock, Unlock의 회수는 pair가 되어야 한다.</para>
            <para>-</para>
            <para>0을 입력할 경우에만 false반환되며, 나머지는 true</para>
            <para>Notify로 깨어날 경우 true 반환.</para>
            <para>-</para>
            <para>lock 구문과 사용할 수 없다.</para>
            <para>Wait를 호출하는 순간 arg에 Lock이 모두 해제된다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.LockUtils.Wait(System.Int32,System.Object)">
            <summary>
            <para>Wait를 호출하는 순간 모든 Thread의 Lock이 해제된다. => Wait와 Lock을 같은 객체로 사용하지 않는것이 좋다.</para>
            <para>Wait를 했다 하더라도 Lock, Unlock의 회수는 pair가 되어야 한다.</para>
            <para>-</para>
            <para>Timeout발생 false</para>
            <para>Notify로 깨어날 경우 true 반환.</para>
            <para>-</para>
            <para>lock 구문과 사용할 수 없다.</para>
            <para>Wait를 호출하는 순간 arg에 Lock이 모두 해제된다.</para>
            <para>-</para>
            <para>-1 or Timeout.Infinite를 넣을 경우 무한대기</para>
            <para>0일 경우 바로 return 됨</para>
            </summary>
            <param name="ms">milli-second</param>
            <param name="obj"></param>
        </member>
        <member name="M:GSG.NET.Concurrent.LockUtils.NotifyAll(System.Object)">
            <summary>
            <para>arg에 대한 전체 Thread 깨움</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.SyncObject.Lock">
            <summary>
            빠른 socket response 를 보정하기 위해서 Lock을 잡아둘경우
            LockUtils.Await의 Monitor.Wait에서 같이 깨워준다
            이로서 Tcp Response를 보정할 수 있다.
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.SyncObject.Await(System.Int32)">
            <summary>
            <para>Notify: true</para>
            <para>Timeout: false</para>
            </summary>
        </member>
        <member name="T:GSG.NET.Concurrent.Task4">
            <summary>
            Task, Parallel
            <para>Task 는 ThreadPool에서 동작하므로 PoolSize를 적절히 적용해야 빠르게 Task 를 생성한다</para>
            <para>-</para>
            <para>Go</para>
            <para>WaitClone, Clone</para>
            <para>WaitAny, WaitAll</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Task4.Idle(System.Int32)">
            <summary>
            cpu 과도 사용 금지
            <para>매번 tick 회수(기본:100) 호출시 1ms 유휴시간</para>
            <para>static 이므로 application 기준 단위</para>
            <para>tick 0일 경우 no sleep</para>
            </summary>
        </member>
        <member name="P:GSG.NET.Concurrent.Task4.ThreadId">
            <summary>Windows Thread Id</summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Task4.PoolSize(System.Int32,System.Int32)">
            <summary>
            min 최초 실행시 확보 및 유지, max 는 임계치
            <para>max 에 도달후 wait 되어 기존 thread 가 종료되면 다시 pool 에서 수행한다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Task4.WaitEx(System.Threading.Tasks.Task)">
            <summary>
            Wait 에서 발생하는 에러처리+logging 확장함수
            <para>Waits for the System.Threading.Tasks.Task to complete execution.</para>
            <para>-</para>
            <para>Go 에서 구동된 Task 의 종료 및 에러처리 관리</para>
            <para>외부에서 exception 사용이 필요한 경우 Wait 사용</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Task4.newActionEx(System.Action)">
            <summary>
            Exception 처리된 새로운 Action copy
            <para>Go 와 사용하는 경우에는 필요없으나 Parallel 과 사용할 경우 필요</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Task4.callEx(System.Action)">
            <summary>실제 호출</summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Task4.call(System.Action)">
            <summary>실제 호출</summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Task4.Go(System.Action)">
            <summary>
            <para>Task 시작</para>
            <para>-</para>
            <para>Exception 처리</para>
            <para>exception 자체 logging</para>
            <para>-</para>
            <para>1. Wait 미사용</para>
            <para>미 처리시에도 crash 발생하지 않음</para>
            <para>-</para>
            <para>2. Wait 사용</para>
            <para>Method 내부에서 처리하지 않을 경우 Wait 에서는 반드시 에러처리 해야함</para>
            <para>-</para>
            <para>3. WaitEx 사용</para>
            <para>에러에 대한 자체 logging 지원, 별도 처리필요 없음</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Task4.Go``1(System.Action{``0},``0)">
            <summary>
            <para>Task 시작</para>
            <para>Go 참조</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Task4.Go``2(System.Action{``0,``1},``0,``1)">
            <summary>
            <para>Task 시작</para>
            <para>Go 참조</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Task4.Go``3(System.Action{``0,``1,``2},``0,``1,``2)">
            <summary>
            <para>Task 시작</para>
            <para>Go 참조</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Task4.WaitClone(System.Int32,System.Action)">
            <summary>
            Parallel
            <para>action 을 poolsize 만큼 복제 및 수행</para>
            <para>-</para>
            <para>Error 처리 필요없음</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Task4.Clone(System.Int32,System.Action)">
            <summary>
            WaitClone 기능 동일, no wait
            <para>action 을 poolsize 만큼 복제 및 수행</para>
            <para>-</para>
            <para>Error 처리 필요없음</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Task4.WaitAll(System.Action[])">
            <summary>
            Actions 수만큼 task 수행, 모두 완료될때 까지 method blocking
            <para>Error 처리 필요없음</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Task4.WaitAll``1(System.Action{``0},``0[])">
            <summary>
            Arguments 수만큼 task 수행, 모두 완료될때 까지 method blocking
            <para>Error 처리 필요없음</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Task4.WaitAll(System.Single,GSG.NET.Concurrent.TaskCancel,System.Action[])">
            <summary>
            Actions 수만큼 task 수행, 모두 완료될때 까지 method blocking
            <para>무한 timeout(-1)</para>
            <para>-</para>
            <para>timeout: false, 완료: true</para>
            <para>-</para>
            <para>Error 처리 필요없음</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Task4.WaitAll``1(System.Single,GSG.NET.Concurrent.TaskCancel,System.Action{``0},``0[])">
            <summary>
            Action arguments 수만큼 task 수행, 모두 완료될때 까지 method blocking
            <para>무한 timeout(-1)</para>
            <para>-</para>
            <para>timeout: false, 완료: true</para>
            <para>-</para>
            <para>Error 처리 필요없음</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Task4.WaitAny(System.Single,System.Action[])">
            <summary>
            Actions 수만큼 task 수행, 가장 빨리 끝나는 task 있을때까지 blocking
            <para>가장 빨리 끝난 method 의 index return, timeout 경우 -1</para>
            <para>무한 timeout(-1)</para>
            <para>-</para>
            <para>Error 처리 필요없음</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Task4.WaitAny(System.Single,GSG.NET.Concurrent.TaskCancel,System.Action[])">
            <summary>
            Actions 수만큼 task 수행, 가장 빨리 끝나는 task 있을때까지 blocking
            <para>가장 빨리 끝난 method 의 index return, timeout 경우 -1</para>
            <para>무한 timeout(-1)</para>
            <para>-</para>
            <para>Error 처리 필요없음</para>
            <para>-</para>
            <para>TaskCancel.CancelWait 와 병행사용</para>
            <para>FastTask or timeout 이 발생하면 사용 필요</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Task4.WaitAny``1(System.Single,System.Action{``0},``0[])">
            <summary>
            Action arguments 수만큼 task 수행, 가장 빨리 끝나는 task 있을때까지 method blocking
            <para>가장 빨리 끝난 arg 값을 return</para>
            <para>무한 timeout(-1)</para>
            <para>timeout 발생한 경우 default value 반환</para>
            <para>-</para>
            <para>Error 처리 필요없음</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Task4.WaitAny``1(System.Single,GSG.NET.Concurrent.TaskCancel,System.Action{``0},``0[])">
            <summary>
            Action arguments 수만큼 task 수행, 가장 빨리 끝나는 task 있을때까지 method blocking
            <para>가장 빨리 끝난 arg 값을 return</para>
            <para>무한 timeout(-1)</para>
            <para>timeout 발생한 경우 default value 반환</para>
            <para>-</para>
            <para>Error 처리 필요없음</para>
            <para>-</para>
            <para>TaskCancel.CancelWait 와 병행사용</para>
            <para>FastTask or timeout 이 발생하면 사용 필요</para>
            </summary>
        </member>
        <member name="T:GSG.NET.Concurrent.TaskCancel">
            <summary>
            Task4's WaitAll, WaitAny 사용
            <para>Timeout 또는 잔여 Task 정리 작업</para>
            <para>-</para>
            <para>Task loop CancelReqd 코드 반영으로 Task 종료 체크</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.TaskCancel.Add(System.Threading.Tasks.Task)">
            <summary>Task 직접 add 하여 cancel 관리시 사용</summary>
        </member>
        <member name="M:GSG.NET.Concurrent.TaskCancel.Callback(System.Action)">
            <summary>Cancel method 호출시 callback 되는 Action 정의</summary>
        </member>
        <member name="P:GSG.NET.Concurrent.TaskCancel.Canceled">
            <summary>
            Task 종료 체크
            <para>Cancel requested</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.TaskCancel.WaitAll">
            <summary>
            Add 된 Tasks 종료 대기 + 객체 재사용 가능
            <para>모두 종료시 새로운 객체로 변경됨: 기존 객체 재사용 가능</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.TaskCancel.Cancel">
            <summary>Cancel trigger</summary>
        </member>
        <member name="T:GSG.NET.Concurrent.Thread4">
            <summary>
            .net4 convert version for ThreadUtils
            <para>Thread.Name은 1회만 세팅 가능</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Thread4.Go(System.Action,System.Boolean)">
            <summary>Start</summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Thread4.GoEx(System.Action,System.Boolean)">
            <summary>
            Start (내부 에러처리 포함)
            <para>Exception 처리 불필요</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Thread4.Pooled(System.Threading.Thread)">
            <summary>source's thread pooled or not</summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Thread4.Stop(System.Threading.Thread)">
            <summary>
            Interrupt
            <para>Wait,Sleep,Join 상태만 유효함</para>
            </summary>
        </member>
        <member name="T:GSG.NET.Concurrent.Threadable">
            <summary>
            <para>상속해서 사용하는 Thread Class</para>
            <para>1. Native Thread ID</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Threadable.Run(System.Object)">
            <summary/>
        </member>
        <member name="M:GSG.NET.Concurrent.Threadable.#ctor">
            <summary/>
        </member>
        <member name="P:GSG.NET.Concurrent.Threadable.IsAlive">
            <summary>
            Thread alive or not
            </summary>
        </member>
        <member name="P:GSG.NET.Concurrent.Threadable.ThreadID">
            <summary>
            Native Thread ID
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Threadable.Start">
            <summary>
            Background thread로 시작한다.
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Threadable.Stop">
            <summary/>
        </member>
        <member name="M:GSG.NET.Concurrent.Threadable.Wait">
            <summary>
            <para>무한 대기, Awake를 하면 바로 실행된다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Threadable.Wait(System.Int32)">
            <summary>
            <para>milli-second만큼 대기, Awake를 하면 바로 실행된다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Threadable.Awake">
            <summary>
            Wait object을 깨워서 다음 동작 수행하게 함.
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.Threadable.ElapsedTime(System.Int64)">
            <summary/>
        </member>
        <member name="P:GSG.NET.Concurrent.ThreadCancel.Canceled">
            <summary>
            Thread 종료 여부 체크
            <para>Cancel requested</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadCancel.Callback(System.Action)">
            <summary>Cancel method 호출시 callback 되는 Action 정의</summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadCancel.AddGo(System.Action)">
            <summary>Thread 생성 후 등록</summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadCancel.AddGoEx(System.Action)">
            <summary>Thread 생성 후 등록</summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadCancel.Cancel">
            <summary>
            Cancel trigger
            <para>Canceled flag 변경</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadCancel.StopWaitAll">
            <summary>
            <para>모든 thread stop(interrupt)</para>
            <para>Wait all thread end</para>
            <para>-</para>
            <para>새로운 CancellationTokenSource 등록!!</para>
            </summary>
        </member>
        <member name="T:GSG.NET.Concurrent.ThreadUtils">
            <summary>
            <para>Method 기반의 Thread 사용 class.</para>
            <para>-</para>
            <para>ThreadPool을 이용한 Thread 생성 및 PoolSize 지정</para>
            <para>InitPoolSize</para>
            <para>InvokePool</para>
            <para>-</para>
            <para>일반 backgroud Thread 실행</para>
            <para>Invoke</para>
            <para>-</para>
            </summary>
        </member>
        <member name="P:GSG.NET.Concurrent.ThreadUtils.ThBgMode">
            <summary/>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadUtils.GetCurrThreadID">
            <summary>
            <para>Win32 Thread 가져오기.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadUtils.InitPoolSize(System.Int32)">
            <summary>
            <para>ThreadPool의 초기 사이즈를 잡는다.</para>
            <para>-</para>
            <para>사용중에 Thread는 InitSize 밑으로 내려갈 수 있지만</para>
            <para>생성이 다시 필요할 경우 InitSize만큼은 빠른 속도로 수행된다.</para>
            <para>-</para>
            <para>초기 생성가 아니며 최소 유지 시키는 사이즈</para>
            <para>-</para>
            </summary>
            <param name="min">Pool Size</param>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadUtils.InitPoolSize(System.Int32,System.Int32)">
            <summary>
            min은 항상 유지, max는 임계치
            <para>max에 도달후 wait되어 기존 thread가 종료되면 다시 pool에서 수행한다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadUtils.InvokePoolEx(System.Action)">
            <summary>
            Logging exception without throw
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadUtils.InvokePoolEx``1(System.Action{``0},``0)">
            <summary>
            Logging exception without throw
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadUtils.InvokePoolEx``2(System.Action{``0,``1},``0,``1)">
            <summary>
            Logging exception without throw
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadUtils.InvokePoolEx``3(System.Action{``0,``1,``2},``0,``1,``2)">
            <summary>
            Logging exception without throw
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadUtils.InvokePoolEx``4(System.Action{``0,``1,``2,``3},``0,``1,``2,``3)">
            <summary>
            Logging exception without throw
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadUtils.InvokePool(System.Action)">
            <summary>
            <para>ThreadPool을 이용한 Invoke</para>
            <para>호출 method는 Poolxxxx 형태의 method naming을 권장함.</para>
            <para>void argument 0 method</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadUtils.InvokePool``1(System.Action{``0},``0)">
            <summary>
            <para>ThreadPool을 이용한 Invoke</para>
            <para>호출 method는 Poolxxxx 형태의 method naming을 권장함.</para>
            <para>void argument 1 method</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadUtils.InvokePool``2(System.Action{``0,``1},``0,``1)">
            <summary>
            <para>ThreadPool을 이용한 Invoke</para>
            <para>호출 method는 Poolxxxx 형태의 method naming을 권장함.</para>
            <para>void argument 2 method</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadUtils.InvokePool``3(System.Action{``0,``1,``2},``0,``1,``2)">
            <summary>
            <para>ThreadPool을 이용한 Invoke</para>
            <para>호출 method는 Poolxxxx 형태의 method naming을 권장함.</para>
            <para>void argument 3 method</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadUtils.InvokePool``4(System.Action{``0,``1,``2,``3},``0,``1,``2,``3)">
            <summary>
            <para>ThreadPool을 이용한 Invoke</para>
            <para>호출 method는 Poolxxxx 형태의 method naming을 권장함.</para>
            <para>void argument 4 method</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadUtils.InvokeEx(System.Action)">
            <summary/>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadUtils.InvokeEx``1(System.Action{``0},``0)">
            <summary>
            Logging exception without throw
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadUtils.InvokeEx``2(System.Action{``0,``1},``0,``1)">
            <summary>
            Logging exception without throw
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadUtils.InvokeEx``3(System.Action{``0,``1,``2},``0,``1,``2)">
            <summary>
            Logging exception without throw
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadUtils.InvokeEx``4(System.Action{``0,``1,``2,``3},``0,``1,``2,``3)">
            <summary>
            Logging exception without throw
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadUtils.Invoke(System.Action)">
            <summary>
            <para>Backgroud thread를 생성하여 invoke</para>
            <para>void argument 0</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadUtils.Invoke``1(System.Action{``0},``0)">
            <summary>
            <para>Backgroud thread를 생성하여 invoke</para>
            <para>void argument 1</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadUtils.Invoke``2(System.Action{``0,``1},``0,``1)">
            <summary>
            <para>Backgroud thread를 생성하여 invoke</para>
            <para>void argument 2</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadUtils.Invoke``3(System.Action{``0,``1,``2},``0,``1,``2)">
            <summary>
            <para>Backgroud thread를 생성하여 invoke</para>
            <para>void argument 3</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadUtils.Invoke``4(System.Action{``0,``1,``2,``3},``0,``1,``2,``3)">
            <summary>
            <para>Backgroud thread를 생성하여 invoke</para>
            <para>void argument 4</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadUtils.Kill(System.Threading.Thread)">
            <summary>
            <para>Thread 강제 kill</para>
            <para></para>
            <para>한번 종료한 Thread는 다시 사용할 수 없다. new 를 이용하여 생성해야 함.</para>
            <para>Socket read 동작은 중단되지 않는다.</para>
            <para>Socket 연결 중 동작은 중단된다.</para>
            <para>Socket 중단 처리를 위해서는 Kill후 Socket을 중단하는 방법 권장.ThreadAbortException 처리 가능.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadUtils.Stop(System.Threading.Thread)">
            <summary>
            <para>1. Interrupt</para>
            <para>2. Join 100ms</para>
            <para>-</para>
            <para>Queue를 사용할 경우 ThreadInterruptedException시 break 구문을 수행하여야 한다.</para>
            </summary>
            <returns>stopped or not</returns>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadUtils.Interrupt(System.Threading.Thread)">
            <summary>
            단순 Interrupt, th thread wait state -> interrupt,
            종료 위해서는 break구문 처리 필요.
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadUtils.IsAlive(System.Threading.Thread)">
            <summary>
            Thread alive or not
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.ThreadUtils.StartSTATask(System.Action)">
            <summary>
            Main Thread 생성
            Chart 와 같은 많은 Data 를 표현 하는 Form 에서 사용
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="T:GSG.NET.Concurrent.TsMap`2">
            <summary>
            Thread-safe Dictionary
            <para>key-value pairs 데이터 thread-safe</para>
            <para>capacity: 32</para>
            <para>concurrency: cpu core *2</para>
            <para>max lock count: 1024</para>
            <para>-</para>
            <para>setter를 사용할 경우 AddOrUpdate가 수행됨</para>
            <para>아래의 코드로 바로 Add 가능함</para>
            <para>dd[key] = value;</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.TsMap`2.Add(`0,`1)">
            <summary>
            key 존재시 ArgumentException
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.TsMap`2.AddOrUpdate(`0,`1)">
            <summary>
            최신 Add값 반영
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.TsMap`2.AddOrKeep(`0,`1)">
            <summary>
            최초 Add값 유지
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.TsMap`2.ContainsKey(`0)">
            <summary/>
        </member>
        <member name="M:GSG.NET.Concurrent.TsMap`2.Clear">
            <summary/>
        </member>
        <member name="P:GSG.NET.Concurrent.TsMap`2.Item(`0)">
            <summary>
            setter를 사용할 경우 AddOrUpdate가 수행됨
            <para>아래의 코드로 바로 Add 가능함</para>
            <para>dd[key] = value;</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.TsMap`2.Remove(`0)">
            <summary/>
        </member>
        <member name="M:GSG.NET.Concurrent.TsMap`2.GetEnumerator">
            <summary/>
        </member>
        <member name="P:GSG.NET.Concurrent.TsMap`2.Count">
            <summary/>
        </member>
        <member name="T:GSG.NET.Concurrent.TsQueue`1">
            <summary>
            Thread safe Queue
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.TsQueue`1.#ctor">
            <summary>
            <para>init size 1024</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.TsQueue`1.#ctor(System.Int32)">
            <summary>
            <para>init size를 정할 수 있다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.TsQueue`1.Enqueue(`0)">
            <summary/>
        </member>
        <member name="M:GSG.NET.Concurrent.TsQueue`1.Dequeue">
            <summary>
            <para>ThreadUtils.Interrupt으로 종료 가능함.</para>
            <para>종료가 안될 경우 ThreadUtils.Stop으로 해도 되나 Interrupt 권장함.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.TsQueue`1.Dequeue(System.Single)">
            <summary>
            dequeue with second
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.TsQueue`1.Dequeue(System.Int32)">
            <summary>
            dequeue sometime wait
            <para>timeout: default(T)</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.TsQueue`1.Pull">
            <summary>
            안전한 데이터 추출
            </summary>
        </member>
        <member name="M:GSG.NET.Concurrent.TsQueue`1.Clear">
            <summary/>
        </member>
        <member name="P:GSG.NET.Concurrent.TsQueue`1.Size">
            <summary/>
        </member>
        <member name="M:GSG.NET.Concurrent.TsQueue`1.GetEnumerator">
            <summary/>
        </member>
        <member name="T:GSG.NET.Extensions.EnumExtensions">
            <summary>
            Enum Extensions 추가
            </summary>
        </member>
        <member name="M:GSG.NET.Extensions.EnumExtensions.GetValues``1">
            <summary>
            Enumerates all enum values
            </summary>
            <typeparam name="T">Enum type</typeparam>
            <returns>IEnumerable containing all enum values</returns>
        </member>
        <member name="M:GSG.NET.Extensions.CastTo`1.From``1(``0)">
            <summary>
            This does not cause boxing for value types.
            Useful in generic methods.
            </summary>
            <typeparam name="S">Source type to cast from. Usually a generic type.</typeparam>
        </member>
        <member name="T:GSG.NET.FileSystem.FileUtils">
            <summary>
            <para>File, Path Utils</para>
            <para>-</para>
            <para>2012.08 닷넷 Path관련 함수 설명 필요해서 내장 시킴</para>
            <para>-</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FileSystem.FileUtils.GetFiles(System.String,System.String,System.Boolean)">
            <summary>
            <para>Directory.GetFiles는 folder가 없을 경우에 에러가 발생하므로 이를 보정함.</para>
            <para>endwith 체크는 array를 다시 한번 체크해야 함, 현재 arrary는 contains임</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FileSystem.FileUtils.GetFileInfos(System.String,System.String,System.Boolean)">
            <summary>
            FileInfos
            <para>endwith 체크는 array를 다시 한번 체크해야 함, 현재 arrary는 contains임</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FileSystem.FileUtils.DeleteFileIfExist(System.String)">
            <summary>
            <para>File.Delete는 directory가 없을 경우에 에러가 발생하므로 이를 보정함.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FileSystem.FileUtils.ChgExtension(System.String,System.String)">
            <summary>
            <para>실제 파일의 확장자를 바꾸지 않고 return 되는 경로 확장자만 바꾸어 진다.</para>
            <para>-</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FileSystem.FileUtils.GetFolderName(System.String)">
            <summary>
            <para>path의 폴더 경로를 가져오며 마지막에 PathSeparator \가 없다.</para>
            <para>e.g.</para>
            <para>C:\\Users\\Administrator\\AppData\\Local\\Temp</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FileSystem.FileUtils.GetFolders(System.String,System.Boolean)">
            <summary>
            <para>Folder가 없을 경우에 에러가 발생하므로 이를 보정함.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FileSystem.FileUtils.CreateFolder(System.String,System.Boolean)">
            <summary>
            <para>Folder생성.</para>
            <para>File or Folder를 지원한다.</para>
            <para>-</para>
            <para>File을 이용해 폴더 만들때 file = true</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FileSystem.FileUtils.GetExtension(System.String)">
            <summary>
            <para>확장자 만을 가져옴 .이 포함된다.</para>
            <para>e.g.</para>
            <para>(.zip)</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FileSystem.FileUtils.GetFileName(System.String)">
            <summary>
            <para>파일 이름(확장자 포함)만 추출하고 싶을 경우</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FileSystem.FileUtils.GetFileNameWithoutExtension(System.String)">
            <summary>
            <para>파일 이름(확장자 없음)만 추출하고 싶을 경우</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FileSystem.FileUtils.GetFullPath(System.String)">
            <summary>
            <para>전체 경로 추출</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FileSystem.FileUtils.GetPathRoot(System.String)">
            <summary>
            <para>루트 경로 추출</para>
            <para>e.g.</para>
            <para>C:\\ or D:\\</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FileSystem.FileUtils.GetRandomFileName">
            <summary>
            <para>Random파일을 생성하여 FileName만 추출한다.</para>
            <para>실제 파일은 만들어 지지 않는다.</para>
            <para>전체 경로를 추출하려면 GetFullPath 활용</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FileSystem.FileUtils.GetTempFileName">
            <summary>
            <para>Temp파일의 전체 경로를 추출한다.</para>
            <para>실제 0바이트의 temp 파일이 생성된다.</para>
            <para>e.g.</para>
            <para>C:\\Users\\Administrator\\AppData\\Local\\Temp\\tmpEC58.tmp</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FileSystem.FileUtils.IsFolder(System.String)">
            <summary>
            <para>Folder or not</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FileSystem.FileUtils.IsFileLocked(System.IO.FileInfo)">
            <summary>
            <para>File이 다른 process가 열고 있는지 체크하는 함수</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FileSystem.FileUtils.OpenRead(System.String,System.Int32)">
            <summary>
            <para>다른 Process가 파일을 수정여부와 상관없이 파일을 열수있다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FileSystem.FileUtils.DirectoryCopy(System.String,System.String,System.Boolean)">
            <summary>
            디렉토리 내용을 그대로 복사한다.
            </summary>
            <param name="sourceDirName"></param>
            <param name="destDirName"></param>
            <param name="copySubDirs"></param>
        </member>
        <member name="T:GSG.NET.FileSystem.FileWatcher">
            <summary>
            FileWatcher
            </summary>
        </member>
        <member name="E:GSG.NET.FileSystem.FileWatcher.OnFileChanged">
            <summary>
            <para>arg: FileSystemEventArgs</para>
            <para>File 변경시 이벤트 발생.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FileSystem.FileWatcher.#ctor">
            <summary/>
        </member>
        <member name="P:GSG.NET.FileSystem.FileWatcher.Path">
            <summary>
            Fullpath or 상대경로
            </summary>
        </member>
        <member name="P:GSG.NET.FileSystem.FileWatcher.Filter">
            <summary>
            <para>default: *.*</para>
            <para>example: *.csv</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FileSystem.FileWatcher.Watch">
            <summary>
            Watch start
            </summary>
        </member>
        <member name="T:GSG.NET.FTP.FTPClient">
            <summary>
            <para>WebClient에 CWD를 하는 함수는 없다</para>
            <para>-</para>
            <para>(주의) FTP Remote 경로는 모두 FTP 접속시 접근되는 폴더 기준으로 해야한다.</para>
            <para>-</para>
            <para>2012.07</para>
            <para>UploadFile함수 기능 보강.</para>
            <para>-</para>
            </summary>
        </member>
        <member name="F:GSG.NET.FTP.FTPClient.lock1">
            <summary>
            Webclient Support Only One IO
            </summary>
        </member>
        <member name="F:GSG.NET.FTP.FTPClient.ANONYMOUS">
            <summary>Anonymous User ID</summary>
        </member>
        <member name="P:GSG.NET.FTP.FTPClient.User">
            <summary>FTP Client User</summary>
        </member>
        <member name="P:GSG.NET.FTP.FTPClient.IpAddress">
            <summary>FTP IpAddress</summary>
        </member>
        <member name="P:GSG.NET.FTP.FTPClient.Port">
            <summary>FTP Port, Default 21</summary>
        </member>
        <member name="P:GSG.NET.FTP.FTPClient.Password">
            <summary>FTP Password</summary>
        </member>
        <member name="M:GSG.NET.FTP.FTPClient.#ctor">
            <summary/>
        </member>
        <member name="P:GSG.NET.FTP.FTPClient.Proxy">
            <summary>
            <para>Proxy</para>
            <para>-</para>
            <para>Default null</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FTP.FTPClient.CheckCredential">
            <summary>
            <para>필수 체크 항목</para>
            <para>-</para>
            <para>1. 계정 세팅 connect 호출 여부 체크.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FTP.FTPClient.Connect">
            <summary>
            <para>User, Password 접속 정보만 세팅하며</para>
            <para>바로 접속은 하지 않고 필요시 연결은 자동으로 처리한다.</para>
            <para>User를 세팅하지 않으면 기본 Anonymous User로 접속된다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FTP.FTPClient.ListDirectory(System.String)">
            <summary>
            <para>FTP server 원격 ListDirectory 목록 조회.</para>
            <para>-</para>
            <para>현재 경로 List가져오기</para>
            <para>ListDirectory("/")</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FTP.FTPClient.GetInitDirectory">
            <summary>
            <para>초기 접속 경로</para>
            <para>에러가 발생할 경우 ??를 return한다</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FTP.FTPClient.ChangeFileName(System.String,System.String)">
            <summary>
            <para>예제.</para>
            <para>ChangeFileName("/aaa.bbb", "aaa.ccc")</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FTP.FTPClient.MakeDirectory(System.String)">
            <summary>
            <para>Directory 생성이 필요할 경우마다 호출함, Exception이 발생하지 않으며 Debug로그만 Write한다.</para>
            <para>-</para>
            <para>모든 경로는 접속시 기본 경로에서 시작한다.</para>
            <para>-</para>
            <para>접속시 기본 경로: /home/fms</para>
            <para>//home/fms/FTP 만들기 예제</para>
            <para>-</para>
            <para>상대 경로로 만들 경우</para>
            <para>/FTP 앞에 /를 붙여 줘야 한다.</para>
            <para>-</para>
            <para>절대 경로로 만들 경우</para>
            <para>//home/fms/FTP</para>
            <param name="dir"></param>
            </summary>
        </member>
        <member name="M:GSG.NET.FTP.FTPClient.DeleteFile(System.String)">
            <summary>
            <para>Delete Remote File or Directory</para>
            </summary>
            <param name="remote">File or Directory</param>
        </member>
        <member name="M:GSG.NET.FTP.FTPClient.DownloadFile(System.String)">
            <summary>
            <para>Use DownloadFile(remotePath, localPath)</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FTP.FTPClient.DownloadFile(System.String,System.String)">
            <summary>
            <para>Sync 방식 File Download</para>
            <para>-</para>
            <para>모든 경로는 접속시 기본 경로에서 시작한다.</para>
            <para>-</para>
            <para>접속시 기본 경로: /home/fms</para>
            <para>//home/fms/FTP/aaa.txt Download 예제</para>
            <para>-</para>
            <para>상대 경로 Download</para>
            <para>DownloadFile(/FTP/aaa.txt, c:\aaa.txt)</para>
            <para>-</para>
            <para>절대 경로 Download</para>
            <para>DownloadFile("//home/fms/FTP/aaa.txt", "c:\aaa.txt")</para>
            <para>-</para>/// </summary>
            <param name="remotePath"></param>
            <param name="localPath"></param>
        </member>
        <member name="M:GSG.NET.FTP.FTPClient.UploadFile(System.String,System.String)">
            <summary>
            <para>Sync방식 Upload FTP</para>
            <para>-</para>
            <para>모든 경로는 접속시 기본 경로에서 시작한다.</para>
            <para>-</para>
            <para>remoteFileName에는 파일 이름을 써줘야 한다.</para>
            <para>-</para>
            <para>접속시 기본 경로: /home/fms</para>
            <para>//home/fms/FTP/aaa.txt파일 올리기 예제</para>
            <para>-</para>
            <para>상대 경로 Upload</para>
            <para>UploadFile(/FTP/aaa.txt, c:\aaa.txt)</para>
            <para>-</para>
            <para>절대 경로 Upload</para>
            <para>UploadFile(//home/fms/FTP/aaa.txt, c:\aaa.txt)</para>
            <para>-</para>
            <para>주의: Server에 해당 파일이 있을 경우는 Option에 따라 다르게 동작함</para>
            <para>Delete 권한 있을 경우: Overwrite</para>
            <para>Delete 권한 없을 경우: 에러 발생함</para>
            <para>-</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FTP.FTPClient.UploadFileAsync(System.String,System.String)">
            <summary>
            <para>비동기 FTP File Upload Request</para>
            <para>-</para>
            <para>경로는 UploadFile을 참고한다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.FTP.FTPClient.ToString">
            <summary>
            ("FTPClient '{0}/{1}' '{2}:{3}'", IpAddress, Port, User, Password);
            </summary>
        </member>
        <member name="T:GSG.NET.IO.ConsoleOutputter">
            <summary>
            console data를 richtext box로 redirect하는 class
            </summary>
        </member>
        <member name="M:GSG.NET.IO.ConsoleOutputter.ChangeFontColor(System.Drawing.Color)">
            <summary>
            <para>ChangeFontColor를 호출한 다음부터 logger의 Font Color가 변경된다.</para>
            <para>화면 Thread에서 호출해야 함.</para>
            </summary>
            <param name="color"></param>
        </member>
        <member name="M:GSG.NET.IO.ConsoleOutputter.Output">
            <summary>
            <para>redirect 시작.</para>
            </summary>
        </member>
        <member name="P:GSG.NET.IO.ConsoleOutputter.LinesWaterMark">
            <summary>
            <para>richtext clear할 라인수</para>
            </summary>
        </member>
        <member name="P:GSG.NET.IO.ConsoleOutputter.TextBox">
            <summary>
            <para>console data redirect 되는 richtext</para>
            </summary>
        </member>
        <member name="T:GSG.NET.IO.MbCommUtils">
            <summary>
            Modbus Serial Comm Utils
            </summary>
        </member>
        <member name="M:GSG.NET.IO.MbCommUtils.ReadReqCrcRTU(System.Int32,System.Byte,System.Int32,System.Int32)">
            <summary/>
        </member>
        <member name="M:GSG.NET.IO.MbCommUtils.WriteSingleWordCrcRTU(System.Int32,System.Byte,System.Int32,System.Int32)">
            <summary/>
        </member>
        <member name="M:GSG.NET.IO.MbCommUtils.WriteWordCrcRTU(System.Int32,System.Byte,System.Int32,System.Byte[])">
            <summary/>
        </member>
        <member name="M:GSG.NET.IO.MbCommUtils.ReadRspCrcRTU(GSG.NET.IO.SerialComm)">
            <summary/>
        </member>
        <member name="M:GSG.NET.IO.MbCommUtils.CrcCheck(GSG.NET.Utils.MemoryBuffer)">
            <summary/>
        </member>
        <member name="T:GSG.NET.IO.SerialComm">
            <summary>
            <para>SerialComm</para>
            <para>ThreadUtils.Interrupt를 사용하면 안됨. 프로그램 죽음</para>
            <para>Close와 IOException을 처리해야 함.</para>
            </summary>
        </member>
        <member name="P:GSG.NET.IO.SerialComm.RetryCount">
            <summary/>
        </member>
        <member name="P:GSG.NET.IO.SerialComm.H">
            <summary/>
        </member>
        <member name="M:GSG.NET.IO.SerialComm.#ctor">
            <summary>
            <para>readtimeout=1000;</para>
            </summary>
        </member>
        <member name="P:GSG.NET.IO.SerialComm.IsOpen">
            <summary>
            SerialPort is open or not
            </summary>
        </member>
        <member name="P:GSG.NET.IO.SerialComm.ReadTimeout">
            <summary>
            <para>Blocking ReadTimeout milli-second</para>
            <para>-</para>
            <para>1000ms (Default)</para>
            <para>Infinite: -1</para>
            <para>0: Exception</para>
            </summary>
        </member>
        <member name="P:GSG.NET.IO.SerialComm.NewLine">
            <summary>
            <para>ReadLine, WriteLine함수를 이용할 경우 NewLine 구분자</para>
            <para>Default: Environment.NewLine</para>
            <para>"\r"; 0xD</para>
            <para>"\n"; 0xA(Default)</para>
            </summary>
        </member>
        <member name="P:GSG.NET.IO.SerialComm.PortName">
            <summary>
            COM1(Default), COM2, ...
            </summary>
        </member>
        <member name="P:GSG.NET.IO.SerialComm.DiscardNull">
            <summary>
            <para>Normally False</para>
            <para>null bytes are ignored</para>
            </summary>
        </member>
        <member name="P:GSG.NET.IO.SerialComm.BaudRate">
            <summary>
            <para>2400</para>
            <para>4800</para>
            <para>7200</para>
            <para>9600(Default)</para>
            <para>14400</para>
            <para>19200</para>
            <para>38400</para>
            <para>57600</para>
            <para>115200</para>
            </summary>
        </member>
        <member name="P:GSG.NET.IO.SerialComm.Parity">
            <summary>
            <para>Parity.None(Default)</para>
            <para>Parity.Odd</para>
            <para>Parity.Even</para>
            <para>Parity.Mark</para>
            <para>Parity.Space</para>
            </summary>
        </member>
        <member name="P:GSG.NET.IO.SerialComm.DataBits">
            <summary>
            <para>7</para>
            <para>8(Default)</para>
            </summary>
        </member>
        <member name="P:GSG.NET.IO.SerialComm.StopBits">
            <summary>
            <para>StopBits.None</para>
            <para>StopBits.One(Default)</para>
            <para>StopBits.Two</para>
            </summary>
        </member>
        <member name="P:GSG.NET.IO.SerialComm.Handshake">
            <summary>
            <para>Handshake.None(Default)</para>
            <para>Handshake.XOnXOff</para>
            <para>Handshake.RequestToSend</para>
            <para>Handshake.RequestToSendXOnXOff</para>
            </summary>
        </member>
        <member name="P:GSG.NET.IO.SerialComm.Encoding">
            <summary>
            <para>Encoding.UTF7</para>
            <para>Encoding.BigEndianUnicode</para>
            <para>Encoding.Unicode</para>
            <para>Encoding.Default</para>
            <para>Encoding.ASCII</para>
            <para>Encoding.UTF8</para>
            <para>Encoding.UTF32</para>
            </summary>
        </member>
        <member name="M:GSG.NET.IO.SerialComm.Open">
            <summary>
            open serial port
            </summary>
        </member>
        <member name="M:GSG.NET.IO.SerialComm.Close">
            <summary>
            close SerailPort
            </summary>
        </member>
        <member name="M:GSG.NET.IO.SerialComm.QuietClose">
            <summary>
            Ignore close error
            </summary>
        </member>
        <member name="P:GSG.NET.IO.SerialComm.IsReadDataExist">
            <summary>
            BytesToRead > 0
            </summary>
        </member>
        <member name="M:GSG.NET.IO.SerialComm.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="M:GSG.NET.IO.SerialComm.Clean">
            <summary>
            DiscardInBuffer();
            DiscardOutBuffer();
            </summary>
        </member>
        <member name="M:GSG.NET.IO.SerialComm.CleanIn">
            <summary>
            Clean read buffer
            </summary>
        </member>
        <member name="M:GSG.NET.IO.SerialComm.CleanOut">
            <summary>
            Clean write buffer
            </summary>
        </member>
        <member name="M:GSG.NET.IO.SerialComm.WriteLeInt(System.Int32)">
            <summary>
            Write little endian int
            </summary>
        </member>
        <member name="M:GSG.NET.IO.SerialComm.WriteLeShort(System.Int32)">
            <summary>
            <para>Write little endian short</para>
            <para>-32768 ~ 32767</para>
            </summary>
        </member>
        <member name="M:GSG.NET.IO.SerialComm.WriteBeInt(System.Int32)">
            <summary>
            Write big endian int
            </summary>
        </member>
        <member name="M:GSG.NET.IO.SerialComm.WriteBeShort(System.Int32)">
            <summary>
            <para>Write big endian short</para>
            <para>-32768 ~ 32767</para>
            </summary>
        </member>
        <member name="M:GSG.NET.IO.SerialComm.ReadBeShort">
            <summary>
            Read big endian short
            </summary>
        </member>
        <member name="M:GSG.NET.IO.SerialComm.ReadBeUshort">
            <summary>
            Read big endian ushort
            </summary>
        </member>
        <member name="M:GSG.NET.IO.SerialComm.ReadBeInt">
            <summary>
            Read big endian int
            </summary>
        </member>
        <member name="M:GSG.NET.IO.SerialComm.ReadLeShort">
            <summary>
            Read little endian short
            </summary>
        </member>
        <member name="M:GSG.NET.IO.SerialComm.ReadLeInt">
            <summary>
            Read little endian int
            </summary>
        </member>
        <member name="M:GSG.NET.IO.SerialComm.ReadAscii(System.Int32)">
            <summary>
            <para>Read string</para>
            <para>Encoding.ASCII</para>
            </summary>
        </member>
        <member name="M:GSG.NET.IO.SerialComm.ReadAscii(System.Int32,System.Text.Encoding)">
            <summary>
            <para>Read string</para>
            </summary>
        </member>
        <member name="M:GSG.NET.IO.SerialComm.ReadBytes(System.Int32)">
            <summary>
            <para>blocing read</para>
            </summary>
        </member>
        <member name="M:GSG.NET.IO.SerialComm.ReadUntil(System.Byte)">
            <summary>
            <para>NewLine, ETX까지 읽는 경우.</para>
            <para>b는 포함되지 않음</para>
            <para>in stream에서 b 까지 읽음</para>
            </summary>
        </member>
        <member name="M:GSG.NET.IO.SerialComm.Write(System.String)">
            <summary>
            
            </summary>
        </member>
        <member name="M:GSG.NET.IO.SerialComm.Write(System.Int32)">
            <summary>
            <para>int -> byte로 변경해서 Write(byte[] bs)호출.</para>
            <para>0~255 argument</para>
            </summary>
        </member>
        <member name="M:GSG.NET.IO.SerialComm.Write(System.Byte[])">
            <summary>
            
            </summary>
        </member>
        <member name="M:GSG.NET.IO.SerialComm.WriteLine(System.String)">
            <summary>
            
            </summary>
        </member>
        <member name="M:GSG.NET.IO.SerialComm.ReadLine">
            <summary>
            
            </summary>
        </member>
        <member name="M:GSG.NET.IO.SerialComm.Read1Byte">
            <summary>
            <para>Block until read 1 byte</para>
            </summary>
        </member>
        <member name="T:GSG.NET.IO.SpDetail">
            <summary>
            <para>SerialPort Detail Config</para>
            </summary>
        </member>
        <member name="M:GSG.NET.IO.SpDetail.#ctor">
            <summary/>
        </member>
        <member name="P:GSG.NET.IO.SpDetail.BaudRate">
            <summary>
            <para>2400</para>
            <para>4800</para>
            <para>7200</para>
            <para>9600(Default)</para>
            <para>14400</para>
            <para>19200</para>
            <para>38400</para>
            <para>57600</para>
            <para>115200</para>
            </summary>
        </member>
        <member name="P:GSG.NET.IO.SpDetail.Parity">
            <summary>
            <para>Parity.None(Default)</para>
            <para>Parity.Odd</para>
            <para>Parity.Even</para>
            <para>Parity.Mark</para>
            <para>Parity.Space</para>
            </summary>
        </member>
        <member name="P:GSG.NET.IO.SpDetail.StopBits">
            <summary>
            <para>StopBits.None</para>
            <para>StopBits.One(Default)</para>
            <para>StopBits.Two</para>
            </summary>
        </member>
        <member name="P:GSG.NET.IO.SpDetail.DataBits">
            <summary>
            <para>7</para>
            <para>8(Default)</para>
            </summary>
        </member>
        <member name="P:GSG.NET.IO.SpDetail.Handshake">
            <summary>
            <para>None(Default)</para>
            </summary>
        </member>
        <member name="T:GSG.NET.LINQ.FwCompress">
            <summary>
            Linq archive
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwCompress.FwZip(System.Byte[],System.Int32)">
            <summary>
            byte array 압축
            <para>객체 압축용</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwCompress.FwZip(System.String,System.Int32)">
            <summary>
            string 압축
            <para>Unzip이 zip의 4배 성능 빠름</para>
            <para>buffer size는 kb 단위로 입력하며 평균 압축 사이즈 기준 설정</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwCompress.FwUnzip(System.String)">
            <summary>
            string 압축 해제
            <para>Unzip이 zip의 4배 성능 빠름</para>
            <para>Zip string이 아닐 경우 string.Empty: No exception</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwCompress.FwUnzip(System.Byte[],System.Int32)">
            <summary>
            byte array 압축 해제
            <para>객체 압축 해제용</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwCompress.FwSz(System.Object)">
            <summary>
            serialize
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwCompress.FwDsz(System.Byte[])">
            <summary>
            deserialize
            </summary>
        </member>
        <member name="T:GSG.NET.LINQ.FwEnum">
            <summary>
            Enum 확장함수
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwEnum.FwIntOf(System.Enum)">
            <summary>
            enum to int value
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwEnum.FwEnumOf``1(``0,System.String)">
            <summary>
            string to enum
            <para>enum e = 0;</para>
            <para>e.FwEnumOf("VVV");</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwEnum.FwEnumOf``1(``0,System.Int32)">
            <summary>
            int to enum
            </summary>
        </member>
        <member name="T:GSG.NET.LINQ.FwLambda">
            <summary>
            <para>TopN:Linq 기본함수. Skip, Take 사용.</para>
            <para>Any</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwLambda.FwNth``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary>
            <para>index 기준 가져오기</para>
            <para>-</para>
            <para>짝수: FwNth(2,0);</para>
            <para>홀수: FwNth(2,1);</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwLambda.FwEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Count, Length ==0
            <para>source == null: true</para>
            <para>string의 Length체크 기능도 됨: FwNull은 NSS_NULL value이므로 이함수 사용도 가능함.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwLambda.FwEmpty(System.String,System.Boolean)">
            <summary>
            Kang Make.
            </summary>
            <param name="source"></param>
            <param name="trim"></param>
            <returns></returns>
        </member>
        <member name="M:GSG.NET.LINQ.FwLambda.FwOrdAsc``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            OrderBy(selector).ToList() 코드 축소형
            <para>기본형은 Labmda 사용 권장</para>
            <para>IOrderedEnumerable을 List로 변경됨 유의!!</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwLambda.FwOrdDesc``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            OrderByDescending(selector).ToList() 코드 축소형
            <para>기본형은 Labmda 사용 권장</para>
            <para>IOrderedEnumerable을 List로 변경됨 유의!!</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwLambda.FwGroupKey``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            GroupBy Key를 List로 반환함.
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwLambda.FwGroupList``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            GroupBy (Key+List) Dictionary
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwLambda.FwEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            <para>List에서만 수행되는 ForEach를 IEnumerable 에서도 수행가능.</para>
            <para>-</para>
            <para>!! FwEach 2개 이상 사용시 반드시 ToList로 변경 후 호출.</para>
            <para>Select로 가져온 IEnumerable은 Cursor가 마지막 위치 이므로 Loop를 수행하지 않음.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwLambda.FwEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            foreach에서 index를 활용하고 싶을 경우 사용
            <para>List.FwEach((x,idx)=> ...)</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwLambda.FwContains``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            <para>source 객체의 특정 Property항목중 comp를 포함하는 List 추출.</para>
            <para>!! comp의 입력 순서를 보장한다, 20151204</para>
            <para>e.g.)var v = ll.FwContains(x => x.IntX, new int[] { 2, 3 });</para>
            <para>e.g.)var v = ll.FwContains(x => x.IntX, lly.Select(y => y.IntY));</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwLambda.FwSort``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            <para>기본 Sort, Argument 없는 OrderBy와 동일함.</para>
            <para>string, int, DateTime등 기본 compare가 있는 타입에 사용가능함.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwLambda.FwSort``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            <para>comp의 기준으로 sort한다.</para>
            <para>comp 포함되지 않는 항목은 뒤로 보내서 위치시킨다.</para>
            <para>-</para>
            <para>var a = ll.FwSort(x => x.IntX);</para>
            <para>var b = ll.FwSort(x => x.StrX, llb.Select(y=> y.xxx));</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwLambda.FwSort``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},``1[])">
            <summary>
            <para>comp의 기준으로 sort한다.</para>
            <para>comp 포함되지 않는 항목은 뒤로 보내서 위치시킨다.</para>
            <para>-</para>
            <para>var a = ll.FwSort(x => x.IntX);</para>
            <para>var b = ll.FwSort(x => x.StrX, new string[] { "0004", "0002", });</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwLambda.FwTake``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},``1,``1)">
            <summary>
            from~to 부분을 Take함.
            <para>to 는 from 이후의 최초 발견되는 to까지 찾는다.</para>
            <para>from이 없거나 to가 없는 경우 exception</para>
            <para>from 이후 to가 없을 경우 exception</para>
            <para>-</para>
            <para>var a = ll.FwTake(x => x.IntX, 2, 6);</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwLambda.FwNothing``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            조건을 만족하는 element가 하나도 없으면.. true
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwLambda.FwDistinct``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Selector 기준 중복 제거
            </summary>
        </member>
        <member name="T:GSG.NET.LINQ.FwNumber">
            <summary>
            Number 관련 함수
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwNumber.FwBlur(System.Int32,System.Int32)">
            <summary>
            숫자 흐리게 하기
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwNumber.FwBtw``1(``0,``0,``0)">
            <summary>
            Between
            <para>Linq, NssModel 사용가능</para>
            <para>MongoModel 사용불가</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwNumber.FwBtw(System.Int32,System.Double,System.Double)">
            <summary>
            Between
            <para>Linq, NssModel 사용가능</para>
            <para>MongoModel 사용불가</para>
            <para>-</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwNumber.FwBtw``1(System.String,``0,``0)">
            <summary>
            Between
            <para>Linq, NssModel 사용가능</para>
            <para>MongoModel 사용불가</para>
            <para>-</para>
            <para>TryParse 에러 return false</para>
            <para>int,long,float,double,datetime 지원</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwNumber.FwMin``1(``0,``0)">
            <summary/>
        </member>
        <member name="M:GSG.NET.LINQ.FwNumber.FwMax``1(``0,``0)">
            <summary/>
        </member>
        <member name="M:GSG.NET.LINQ.FwNumber.FwDivEq0(System.Int32,System.Int32)">
            <summary>
            배수체크
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwNumber.FwIntOf(System.String,System.Int32)">
            <summary>
            <para>Exception이 발생하지 않으며 parse fail 경우 기본값: def 반환</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwNumber.FwIntOf(System.Double)">
            <summary>
            double to int32
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwNumber.FwIntOf(System.Single)">
            <summary>
            float to int32
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwNumber.FwIntOf(System.Decimal)">
            <summary>
            decimal to int32
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwNumber.FwIntOf(System.String,System.Boolean)">
            <summary>
            <para>Hexa format string parsing</para>
            <para>Exception이 발생하지 않으며 기본값 반환</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwNumber.FwFloatOf(System.Decimal)">
            <summary>
            decimal to float
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwNumber.FwFloatOf(System.String)">
            <summary>
            <para>Exception이 발생하지 않으며 기본값 반환</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwNumber.FwDoubleOf(System.String)">
            <summary>
            <para>Exception이 발생하지 않으며 기본값 반환</para>
            </summary>
        </member>
        <member name="T:GSG.NET.LINQ.FwStats">
            <summary>
            Number 관련 함수
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwStats.FwAvg``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            source count 0 일 경우 exception 방지
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwStats.FwVariance``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            <para>분포도(분산)</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwStats.FwStdDev``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            <para>표준편차</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwStats.FwMedian``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Median 구하기
            <para>홀수 샘플: 중간값</para>
            <para>짝수 샘플: 중간값 2개 / 2</para>
            </summary>
        </member>
        <member name="T:GSG.NET.LINQ.FwString">
            <summary/>
        </member>
        <member name="M:GSG.NET.LINQ.FwString.FwFormat(System.DateTime,System.String)">
            <summary>
            '/'를 넣을수 있는 InvariantInfo
            <para>ToString(format, System.Globalization.DateTimeFormatInfo.InvariantInfo)</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwString.FwFormat(System.String,System.Object[])">
            <summary>
            string.Format 대체
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwString.FwLog``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Object},System.String)">
            <summary>
            List의 Property를 ,기준으로 string화 처리
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwString.FwNull(System.String)">
            <summary>
            Nss null string check 함수
            <para>string.IsNullOrEmpty이거나 Foco.NSS_NULL_STRING 입력값과 동일하면 true</para>
            <para>-</para>
            <para>일반 string 비교일 경우 FwEmpty를 사용해야 함</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwString.FwSplit(System.String,System.String[])">
            <summary>
            RemoveEmptyEntries option split
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwString.FwSplit(System.String,System.Char[])">
            <summary>
            RemoveEmptyEntries option split
            </summary>
        </member>
        <member name="M:GSG.NET.LINQ.FwString.FwEmpty(System.String,System.Boolean)">
            <summary>
            string.IsNullOrEmpty
            <para>string이 null 일 경우에도 사용가능</para>
            <para>Trim은 옵션으로 체크</para>
            </summary>
        </member>
        <member name="P:GSG.NET.Logging.NotifyAppender.Notification">
            <summary>
            Get or set the notification message.
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.NotifyAppender.OnChange">
            <summary>
            Raise the change notification.
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.NotifyAppender.Append(log4net.Core.LoggingEvent)">
            <summary>
            Append the log information to the notification.
            </summary>
            <param name="loggingEvent">The log event.</param>
        </member>
        <member name="M:GSG.NET.Logging.AppenderUtils.RemoveAppender(log4net.Repository.Hierarchy.Logger,System.String)">
            <summary>
            <para>1. Logger에서 Appender 제거함.</para>
            <para>2. Close Appender</para>
            </summary>
            <param name="logger"></param>
            <param name="name"></param>
        </member>
        <member name="T:GSG.NET.Logging.CsvAppender">
            <summary>
            Csv Header를 추가한 appender
            <para>def values</para>
            <para>File: CSV</para>
            <para>Name: CsvAppender</para>
            <para>DatePattern: -yyyyMMdd.'csv'</para>
            <para>BackupDays: 30</para>
            </summary>
        </member>
        <member name="P:GSG.NET.Logging.CsvAppender.Header">
            <summary>
            Csv Header
            </summary>
        </member>
        <member name="P:GSG.NET.Logging.CsvAppender.LogPattern">
            <summary>
            <para>Log content pattern</para>
            <para>%m%n</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.CsvAppender.#ctor">
            <summary/>
        </member>
        <member name="M:GSG.NET.Logging.CsvAppender.ActivateOptions">
            <summary/>
        </member>
        <member name="M:GSG.NET.Logging.CsvAppender.WriteHeader">
            <summary/>
        </member>
        <member name="T:GSG.NET.Logging.FileAppender">
            <summary>
            <para>Floware FileAppender</para>
            <para>-</para>
            <para>default value</para>
            <para>BackupDays: 10</para>
            <para>DatePattern: -MMdd'.log'</para>
            <para>Layout: %d{MM-dd HH:mm:ss.fff} %-2.2t %-5p %m%n</para>
            <para>-</para>
            <para>StaticLogFileName: 최초 파일 생성시 datepattern이 적용된 파일로 생성여부.</para>
            <para>default: true, xxx.log</para>
            <para>false: xxx-130405.log</para>
            <para>폴더 생성 모드를 사용할 경우 자동으로 false로 세팅된다.</para>
            <para>-</para>
            <para>PreserveLogFileNameExtension: log4net 1.2.11 이상</para>
            <para>-</para>
            <para>폴더 만들기 예제 File</para>
            <para>"C:/LOG/SECS-I/%d/SECS1"</para>
            <para>-</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.FileAppender.#ctor">
            <summary>
            FileAppender constructor
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.FileAppender.#ctor(log4net.Core.Level)">
            <summary>
            FileAppender constructor
            </summary>
        </member>
        <member name="P:GSG.NET.Logging.FileAppender.BackupDays">
            <summary/>
        </member>
        <member name="M:GSG.NET.Logging.FileAppender.ActivateOptions">
            <summary/>
        </member>
        <member name="M:GSG.NET.Logging.FileAppender.OpenFile(System.String,System.Boolean)">
            <summary/>
        </member>
        <member name="M:GSG.NET.Logging.FileAppender.AdjustFileBeforeAppend">
            <summary>
            Logging을 할때마다 아래 함수가 호출되며
            먼저 파일을 닫고, OpenFile이 호출된다.
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.FileAppender.OnClose">
            <summary>
            appender close
            </summary>
        </member>
        <member name="T:GSG.NET.Logging.Logger">
            <summary>
            Logger wrapping class
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.Logger.GetLogger">
            <summary>
            Logger를 생성한 Class의 Type을 찾아서 Logger를 만든다.
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.Logger.GetLogger(System.Type)">
            <summary>
            Logger factory
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.Logger.GetLogger(System.String)">
            <summary>
            Logger factory
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.Logger.D(System.Object)">
            <summary>
            Debug
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.Logger.D(System.String,System.Object[])">
            <summary>
            DebugFormat
            </summary>
        </member>
        <member name="P:GSG.NET.Logging.Logger.IsDE">
            <summary>
            DebugEnabled
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.Logger.I(System.Object)">
            <summary>
            Info
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.Logger.I(System.String,System.Object[])">
            <summary>
            InfoFormat
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.Logger.W(System.Object)">
            <summary>
            Warn
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.Logger.W(System.String,System.Object[])">
            <summary>
            WarnFormat
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.Logger.E(System.Object)">
            <summary>
            Error
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.Logger.E(System.String,System.Object[])">
            <summary>
            ErrorFormat
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.Logger.F(System.Object)">
            <summary>
            Fatal
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.Logger.F(System.String,System.Object[])">
            <summary>
            FatalFormat
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.LoggerUtils.HasLogger(System.String)">
            <summary>
            Has Logger or not
            </summary>
            <param name="loggerName">LoggerName</param>
        </member>
        <member name="M:GSG.NET.Logging.LoggerUtils.GetLogger(System.String)">
            <summary>
            <para>Logger가 없을 경우 만들어준다.</para>
            <para>AddLogger 기능과 같다.</para>
            </summary>
        </member>
        <member name="T:GSG.NET.Logging.LogUtils">
            <summary>
            <para>Log4Net Utils</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.LogUtils.Configure">
            <summary>
            <para>empty log4net config</para>
            <para>log repository...</para>
            <para>Level: INFO</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.LogUtils.Configure(System.String)">
            <summary>
            <para>Log4net config file loading</para>
            </summary>
            <param name="cfgPath"></param>
        </member>
        <member name="M:GSG.NET.Logging.LogUtils.Configure(System.String,System.Boolean)">
            <summary/>
        </member>
        <member name="P:GSG.NET.Logging.LogUtils.RootLogger">
            <summary>
            <para>Get RootLogger</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.LogUtils.ChangeAdditivity(System.String,System.Boolean)">
            <summary>
            <para>Change additivity option</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.LogUtils.CreateConsoleAppender">
            <summary>
            <para>Create Console Appender</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.LogUtils.CreateConsoleAppender(System.String)">
            <summary/>
            <param name="name">Appender Name</param>
        </member>
        <member name="M:GSG.NET.Logging.LogUtils.CreateConsoleAppender(System.String,log4net.Layout.ILayout)">
            <summary/>
            <param name="name">Appender Name</param>
            <param name="layout"></param>
        </member>
        <member name="M:GSG.NET.Logging.LogUtils.CommonLogging">
            <summary/>
        </member>
        <member name="M:GSG.NET.Logging.LogUtils.ChangeLevel(log4net.Core.Level)">
            <summary>
            <para>RootLogger Change Level</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.LogUtils.ChangeLevel(System.String,log4net.Core.Level)">
            <summary>
            <para>Non-RootLogger Change Level</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.LogUtils.ChangeThreshold(System.String,log4net.Core.Level)">
            <summary>
            <para>Change RootLogger Appender's Level</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.LogUtils.ChangeThreshold(System.String,System.String,log4net.Core.Level)">
            <summary>
            <para>Change Specific Logger Appender's Level</para>
            </summary>
        </member>
        <member name="P:GSG.NET.Logging.LogUtils.DefaultLayout">
            <summary>
            <para>%d{MM-dd HH:mm:ss.fff} %-2.2t %-5p %m%n</para>
            <para>-</para>
            <para>LoggerName: %-10.10c</para>
            <para>-</para>
            <para>%-a.b -:left justify, a:minimum width, b:maximum width</para>
            <para>-</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.LogUtils.CreateLayout(System.String)">
            <summary>
            <para>Pattern layout 생성</para>
            <para>-</para>
            <para>Class: %c</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.LogUtils.AddAppender(log4net.Appender.IAppender)">
            <summary>
            <para>RootLogger AddAppender</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.LogUtils.AddAppender(System.String,log4net.Appender.IAppender)">
            <summary>
            <para>Non-RootLogger AddAppender</para>
            <para>Logger가 없을 경우 생성한다.</para>
            <para>-</para>
            <para>AppenderName이 없을 경우 loggerName을 AppenderName으로 세팅한다.</para>
            <para>-</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.LogUtils.AddAppender(System.String,log4net.Appender.IAppender,System.Boolean)">
            <summary>
            <para>Non-RootLogger AddAppender</para>
            <para>Logger가 없을 경우 생성한다.</para>
            <para>-</para>
            <para>AppenderName이 없을 경우 loggerName을 AppenderName으로 세팅한다.</para>
            <para>-</para>
            <para>Additivity option</para>
            <para>-</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.LogUtils.RemoveAppender(System.String)">
            <summary>
            <para>RootLogger</para>
            <para>-</para>
            <para>1. RootLogger에서 Appender 제거함.</para>
            <para>2. Close Appender</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Logging.LogUtils.RemoveAppender(System.String,System.String)">
            <summary>
            <para>Non-RootLogger</para>
            <para>-</para>
            <para>1. Logger에서 Appender 제거함.</para>
            <para>2. Close Appender</para>
            </summary>
        </member>
        <member name="T:GSG.NET.ObjectBase.SingletonBase`1">
            <summary>
            A base class for the singleton design pattern.
            </summary>
            <typeparam name="T">Class type of the singleton</typeparam>
        </member>
        <member name="F:GSG.NET.ObjectBase.SingletonBase`1.sInstance">
            <summary>
            Static instance. Needs to use lambda expression
            to construct an instance (since constructor is private).
            </summary>
        </member>
        <member name="P:GSG.NET.ObjectBase.SingletonBase`1.Instance">
            <summary>
            Gets the instance of this singleton.
            </summary>
        </member>
        <member name="M:GSG.NET.ObjectBase.SingletonBase`1.CreateInstanceOfT">
            <summary>
            Creates an instance of T via reflection since T's constructor is expected to be private.
            </summary>
            <returns></returns>
        </member>
        <member name="T:GSG.NET.OSView.EventLogSpy">
            <summary>
            <para>Event 로그를 읽는것이 느려서</para>
            <para>EntryWritten을 활용하는 방법으로 구현한다.</para>
            </summary>
        </member>
        <member name="E:GSG.NET.OSView.EventLogSpy.OnEntryWritten">
            <summary/>
        </member>
        <member name="T:GSG.NET.OSView.EventLogSpy.LogType">
            <summary/>
        </member>
        <member name="F:GSG.NET.OSView.EventLogSpy.LogType.Application">
            <summary/>
        </member>
        <member name="F:GSG.NET.OSView.EventLogSpy.LogType.System">
            <summary/>
        </member>
        <member name="F:GSG.NET.OSView.EventLogSpy.LogType.Security">
            <summary/>
        </member>
        <member name="F:GSG.NET.OSView.EventLogSpy.LogType.Setup">
            <summary/>
        </member>
        <member name="M:GSG.NET.OSView.EventLogSpy.Watch(GSG.NET.OSView.EventLogSpy.LogType)">
            <summary/>
        </member>
        <member name="M:GSG.NET.OSView.EventLogSpy.Close">
            <summary/>
        </member>
        <member name="M:GSG.NET.OSView.EventLogSpy.WarnOrError(System.Diagnostics.EventLogEntry)">
            <summary>
            <para>Waring 또는 에러인지 검사.</para>
            </summary>
        </member>
        <member name="T:GSG.NET.OSView.Mgnt">
            <summary>
            Management
            </summary>
        </member>
        <member name="M:GSG.NET.OSView.Mgnt.PrinterNames">
            <summary/>
        </member>
        <member name="M:GSG.NET.OSView.Mgnt.CpuUseRate">
            <summary>
            <para>CPU 사용률 % / 100%기준.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.OSView.Mgnt.ProcCpu1UseRate(System.String)">
            <summary>
            <para>Process 의 CPU 사용률</para>
            <para>1 cpu 기준이므로 multi cpu 일 경우 processor count 로 나눠야 한다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.OSView.Mgnt.ProcCpuUseRate(System.String)">
            <summary>
            <para>Logical CPU 기준으로 나눈값</para>
            </summary>
        </member>
        <member name="M:GSG.NET.OSView.Mgnt.ProcMemUseKB(System.String)">
            <summary>
            <para>메모리 사용량 KB</para>
            <para>PrivateMemorySize</para>
            </summary>
        </member>
        <member name="M:GSG.NET.OSView.Mgnt.ProcMemPeakUseKB(System.String)">
            <summary>
            <para>Peak 메모리 사용량 KB</para>
            <para>PrivateMemorySize</para>
            </summary>
        </member>
        <member name="M:GSG.NET.OSView.Mgnt.MemPhysicalKB">
            <summary>
            <para>Physical Memory Size KB 단위 추출</para>
            </summary>
        </member>
        <member name="M:GSG.NET.OSView.Mgnt.MemVirtualKB">
            <summary>   
            <para>Virtual Memory Size KB 단위 추출</para>
            </summary>
        </member>
        <member name="M:GSG.NET.OSView.Mgnt.MemVirtualFreeKB">
            <summary>
            Virtual 기준 Free Kb size
            </summary>
        </member>
        <member name="M:GSG.NET.OSView.Mgnt.MemVirtualUseKB">
            <summary>
            Virtual 기준 Use KB
            </summary>
        </member>
        <member name="M:GSG.NET.OSView.Mgnt.MemPhysicalFreeKB">
            <summary>
            Physical 기준 Free size
            </summary>
        </member>
        <member name="M:GSG.NET.OSView.Mgnt.MemPhysicalUseKB">
            <summary>
            Physical 기준 사용량 KB
            </summary>
        </member>
        <member name="M:GSG.NET.OSView.Mgnt.MemPhysicalUseRate">
            <summary>
            Physical 기준 100분율
            </summary>
        </member>
        <member name="M:GSG.NET.OSView.Mgnt.OsName">
            <summary>
            <para>OS Name 가져오기.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.OSView.Mgnt.CpuCountLogical">
            <summary>
            <para>Retrieve Total Logical Cpu Count</para>
            </summary>
        </member>
        <member name="M:GSG.NET.OSView.Mgnt.MemVirtualUseRate">
            <summary>
            <para>메모리 사용률 %</para>
            </summary>
        </member>
        <member name="M:GSG.NET.OSView.Mgnt.HddList">
            <summary>
            <para>Ready 상태이고, HDD 드라이브만 추출</para>
            </summary>
        </member>
        <member name="M:GSG.NET.OSView.Mgnt.LocalIpList">
            <summary>
            <para>Local IP Address 가져오기.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.OSView.Mgnt.MacAddressList">
            <summary>
            <para>Local Mac Address 가져오기.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.OSView.Mgnt.Wql(System.String)">
            <summary>
            wql: SQL for WMI
            </summary>
        </member>
        <member name="P:GSG.NET.OSView.Mgnt.Is64BitOperatingSystem">
            <summary>
            32, 64 bit check
            </summary>
        </member>
        <member name="M:GSG.NET.OSView.Mgnt.GetDotnetVersion">
            <summary>
            CLR version retrieve
            </summary>
        </member>
        <member name="M:GSG.NET.OSView.Mgnt.AddFirewall(System.String,System.Int32)">
            <summary>
            Tcp 방화벽 등록.
            </summary>
        </member>
        <member name="M:GSG.NET.OSView.Mgnt.ServiceStart(System.String)">
            <summary/>
        </member>
        <member name="M:GSG.NET.OSView.Mgnt.ServiceStop(System.String)">
            <summary/>
        </member>
        <member name="T:GSG.NET.Poco">
            <summary>
            POCO(Plain Old CLR Object)
            </summary>
        </member>
        <member name="F:GSG.NET.Poco.T_INT">
            <summary>
            Int32 타입과 동일
            </summary>
        </member>
        <member name="F:GSG.NET.Poco.T_LONG">
            <summary>
            Int64 타입과 동일
            </summary>
        </member>
        <member name="F:GSG.NET.Poco.T_FLOAT">
            <summary>
            Single 타입과 동일
            </summary>
        </member>
        <member name="F:GSG.NET.Poco.T_DOUBLE">
            <summary>
            Double 타입과 동일
            </summary>
        </member>
        <member name="M:GSG.NET.Poco.ToString">
            <summary>
            ToString 재정의
            </summary>
        </member>
        <member name="M:GSG.NET.Poco.ChgNullValue(System.String)">
            <summary>
            string Property값이 null일 경우 v로 변경.
            </summary>
        </member>
        <member name="M:GSG.NET.Poco.ChgNullValue">
            <summary>
            string Property값이 null일 경우 string.Empty로 변경.
            </summary>
        </member>
        <member name="F:GSG.NET.Poco.NSS_NULL_STRING">
            <summary>
            Nss Null string setting
            <para>def: string.Empty</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Poco.IntV(System.String)">
            <summary/>
        </member>
        <member name="M:GSG.NET.Poco.DoubleV(System.String)">
            <summary/>
        </member>
        <member name="T:GSG.NET.Interop32">
            <summary>
            <para>const uint FILE_SHARE_READ = 1;</para>
            <para></para>
            <para>const uint FILE_ATTRIBUTE_NORMAL = 0x80;</para>
            <para></para>
            <para>const uint GENERIC_READ = 0x80000000;</para>
            <para>const uint OPEN_EXISTING = 3;</para>
            <para></para>
            <para></para>
            <para></para>
            </summary>
        </member>
        <member name="T:GSG.NET.LinqEx">
            <summary>
            내부적으로 사용하는 Linq 확장함수
            <para>내부적으로 사용한다는 의미에서 소문자로 시작하는 method 화</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LinqEx.avg``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            source count 0 일 경우 exception 방지
            </summary>
        </member>
        <member name="M:GSG.NET.LinqEx.format(System.Text.StringBuilder,System.String,System.Object[])">
            <summary>
            append format
            </summary>
        </member>
        <member name="M:GSG.NET.LinqEx.empty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Count, Length == 0
            <para>source == null: true</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LinqEx.empty(System.String,System.Boolean)">
            <summary>
            string.IsNullOrEmpty
            <para>Trim 은 옵션으로 체크</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LinqEx.multi(System.Single,System.Int32)">
            <summary>
            곱하기
            </summary>
        </member>
        <member name="M:GSG.NET.LinqEx.div(System.Int32,System.Int32)">
            <summary>
            나누기
            </summary>
        </member>
        <member name="M:GSG.NET.LinqEx.remain(System.Int32,System.Int32)">
            <summary>
            나머지
            </summary>
        </member>
        <member name="M:GSG.NET.LinqEx.split(System.String,System.String[])">
            <summary>
            remove empty option 적용, empty string을 제거한다
            </summary>
        </member>
        <member name="M:GSG.NET.LinqEx.stringOf(System.Byte[],System.Text.Encoding)">
            <summary>
            <para>byte array -> string</para>
            <para>null byte 0 -> 0x20</para>
            </summary>
        </member>
        <member name="M:GSG.NET.LinqEx.stringOf(System.Char[])">
            <summary>
            char array -> string
            </summary>
        </member>
        <member name="M:GSG.NET.LinqEx.xFF(System.Byte[])">
            <summary>
            byte -&gt; 2byte(0xff) string
            <para>1,2,3 -gt; 010203</para>
            </summary>
        </member>
        <member name="T:GSG.NET.Quartz.CbTimer">
            <summary>
            Method callback timer
            <para>Timer를 재사용하므로 CbTimer는 여러개 객체 최소화</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Quartz.CbTimer.#ctor">
            <summary/>
        </member>
        <member name="M:GSG.NET.Quartz.CbTimer.Once(System.Action,System.Int32)">
            <summary/>
        </member>
        <member name="M:GSG.NET.Quartz.CbTimer.Repeat(System.Action,System.Int32)">
            <summary>
            이전 Timer가 동작중이면 Stop로직이 이미 포함되어 있음.
            </summary>
        </member>
        <member name="M:GSG.NET.Quartz.CbTimer.Stop">
            <summary/>
        </member>
        <member name="T:GSG.NET.Quartz.QuartzUtils">
            <summary>
            <para>Quartz Lib 구현 class</para>
            <para>CronJob 특성때문에 화면 Thread로 변경하지 않는다.</para>
            <para>호출 메서드에서 에러가 발생하면 내부적으로 로깅하여 Exception이 발생하지 않는다.</para>
            <para>-</para>
            <para>초단위</para>
            <para>매초: * * * * * ?</para>
            <para>5초: 0/5 * * * * ?</para>
            <para>-</para>
            <para>분단위</para>
            <para>매분: 0 * * * * ?</para>
            <para>5분: 0 0/5 * * * ?</para>
            <para>-</para>
            <para>시간단위</para>
            <para>매시간: 0 0 * * * ?</para>
            <para>2시간: 0 0 0/2 * * ?</para>
            <para>-</para>
            <para>일단위</para>
            <para>매일 0시: 0 0 0 * * ?</para>
            <para>-</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Quartz.QuartzUtils.Init(System.Int32)">
            <summary>
            <para>Quartz Factoy 생성</para>
            <para>Argument threadcount는 quartz 수행 개수/2 정도 설정</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Quartz.QuartzUtils.GetExpnSecond(System.Int32)">
            <summary>
            <para>N 초마다 실행되는 expression</para>
            <para>예제: 5초주기 실행 GetExpnSecond(5)</para>
            <para>예제: 10초주기 실행 GetExpnSecond(10)</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Quartz.QuartzUtils.GetExpnMinute(System.Int32)">
            <summary>
            <para>N 분마다 실행되는 expression: GetExpnMinute(10)</para>
            <para>예제: 5분주기 실행 GetExpnMinute(5)</para>
            <para>예제: 10분주기 실행 GetExpnMinute(10)</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Quartz.QuartzUtils.GetExpnHour(System.Int32)">
            <summary>
            <para>N 시간마다 실행되는 expression</para>
            <para>예제: 1시간 실행 GetExpnHour(1)</para>
            <para>예제: 2시간 실행 GetExpnHour(2)</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Quartz.QuartzUtils.GetExpnDay(System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>매일 특정시간</para>
            <para>예제: 매일 1시 2분 3초에 실행 GetExpnDay(1,2,3)</para>
            <para>예제: 매일 밤 12시 실행 GetExpnDay(0,0,0)</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Quartz.QuartzUtils.Invoke(System.String,System.String,System.Action)">
            <summary>
            <para>void 0 argement method를 수행한다.</para>
            <para>CronExpression을 변경하고 싶을 경우 jobName 동일하게 expression만 변경하면 된다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Quartz.QuartzUtils.Invoke(System.String,Quartz.Trigger,System.Action)">
            <summary>
            <para>TriggerUtils를 이용하면 Trigger를 쉽게 만들수 있다.</para>
            <para>-</para>
            <para>예제: QuartzUtils.Invoke("2", TriggerUtils.MakeSecondlyTrigger(10), BBB);</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Quartz.QuartzUtils.StopSchedule(System.String)">
            <summary>
            <para>Stop Schedule</para>
            </summary>
        </member>
        <member name="T:GSG.NET.Quartz.TimeInvokeUtils">
            <summary>
            <para>Timer를 함수로 바로 mapping하여 사용할 경우</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Quartz.TimeInvokeUtils.InvokeOnce(System.Int32,System.Action)">
            <summary>
            <para>한번만 호출됨</para>
            <para>두번째 delegate는 argument가 없는 void 함수명 입력</para>
            <para>e.g. TimerUtils.InvokeOnce(3000, InitHsms);</para>
            </summary>
            <param name="ms">milli-second</param>
            <param name="method">void () target</param>
        </member>
        <member name="M:GSG.NET.Quartz.TimeInvokeUtils.InvokeRepeat(System.Int32,System.Action)">
            <summary>
            <para>지속적인 호출, stop기능은 없다</para>
            <para>stop을 사용하려면 SimpleTimerTemplate, TimerTemplate를 사용함</para>
            <para>두번째 delegate는 argument가 없는 void 함수명 입력</para>
            <para>e.g. TimerUtils.InvokeRepeat(3000, InitHsms);</para>
            </summary>
            <param name="ms">milli-second</param>
            <param name="method"></param>
        </member>
        <member name="T:GSG.NET.Quartz.TimerTemplate`2">
            <summary/>
            <typeparam name="TKey">id (string or int..)</typeparam>
            <typeparam name="TAttch">OnTimeout attach object</typeparam>
        </member>
        <member name="T:GSG.NET.Quartz.TimerTemplate`2.TimeoutDelegate">
            <summary/>
        </member>
        <member name="E:GSG.NET.Quartz.TimerTemplate`2.OnTimeout">
            <summary/>
        </member>
        <member name="M:GSG.NET.Quartz.TimerTemplate`2.HasId(`0)">
            <summary>
            Check prev timer has or not
            </summary>
        </member>
        <member name="M:GSG.NET.Quartz.TimerTemplate`2.StartOnce(System.Int32,`0,`1)">
            <summary>
            1회 timer
            <para>interval: millisecond</para>
            <para>Attach 입력 객체는 OnTimeout invoke시 사용가능</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Quartz.TimerTemplate`2.StartRepeat(System.Int32,`0,`1)">
            <summary>
            반복 timer
            <para>interval: millisecond</para>
            <para>Attach 입력 객체는 OnTimeout invoke시 사용가능</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Quartz.TimerTemplate`2.GetAttachment(`0)">
            <summary/>
        </member>
        <member name="M:GSG.NET.Quartz.TimerTemplate`2.Stop(`0)">
            <summary>
            Stop timer
            </summary>
        </member>
        <member name="M:GSG.NET.Quartz.TimerTemplate`2.StopAll">
            <summary>
            All timer stop
            </summary>
        </member>
        <member name="T:GSG.NET.Quartz.TimerTemplate`2.Task">
            <summary>
            Timer 정보
            </summary>
        </member>
        <member name="P:GSG.NET.Quartz.TimerTemplate`2.Task.MsTimer">
            <summary>
            Microsoft timer
            </summary>
        </member>
        <member name="P:GSG.NET.Quartz.TimerTemplate`2.Task.Attch">
            <summary>
            attachment object
            </summary>
        </member>
        <member name="T:GSG.NET.Quartz.TimerUtils">
            <summary/>
        </member>
        <member name="M:GSG.NET.Quartz.TimerUtils.Repeat(System.Int32,System.Action)">
            <summary/>
        </member>
        <member name="M:GSG.NET.Quartz.TimerUtils.Once(System.Int32,System.Action)">
            <summary>
            무조건 새로운 timer 생성
            <para>CbTimer와는 다름</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Quartz.TimerUtils.Once``1(System.Int32,System.Action{``0},``0)">
            <summary/>
        </member>
        <member name="M:GSG.NET.Quartz.TimerUtils.Once``2(System.Int32,System.Action{``0,``1},``0,``1)">
            <summary/>
        </member>
        <member name="T:GSG.NET.TCP.SocketTimeoutException">
            <summary>
            Socket timeout 발생시 
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.SocketTimeoutException.#ctor(System.String)">
            <summary/>
        </member>
        <member name="T:GSG.NET.TCP.Tcp4">
            <summary>
            <para>2016.06.15 최초 개발</para>
            <para>default: BigEndian</para>
            <para>MaxBufSize 추가 (2018.03)</para>
            </summary>
        </member>
        <member name="P:GSG.NET.TCP.Tcp4.Comm">
            <summary>
            Tcp 연결정보
            <para>-</para>
            <para>기본값</para>
            <para>T2: 30sec</para>
            <para>T5: 5sec</para>
            <para>T6: 10sec</para>
            <para>Retry: infinite</para>
            <para>Active: true</para>
            </summary>
        </member>
        <member name="P:GSG.NET.TCP.Tcp4.Connected">
            <summary>
            tcp connect or not
            <para>Sck == null이면 false</para>
            </summary>
        </member>
        <member name="P:GSG.NET.TCP.Tcp4.LittleEndian">
            <summary>
            default: false, 즉 BigEndian default
            </summary>
        </member>
        <member name="P:GSG.NET.TCP.Tcp4.MaxBufSize">
            <summary>
            Read 함수 호출시 invalid size 체크
            <para>OutOfMemoryException로 인한 application 다운 방어코드</para>
            <para>-</para>
            <para>단위 byte</para>
            <para>Default: 10485760(10mb)</para>
            <para>해당 값보다 클경우 IOException 발생</para>
            </summary>
        </member>
        <member name="P:GSG.NET.TCP.Tcp4.Sck">
            <summary />
        </member>
        <member name="M:GSG.NET.TCP.Tcp4.#ctor">
            <summary>
            <para>TcpIp 통신 class</para>
            <para>-</para>
            <para>기본세팅값</para>
            <para>BigEndian</para>
            <para>MaxBufSize (10mb)</para>
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.Tcp4.ChgTimeout(System.Boolean)">
            <summary>
            T6 기준 infinite timeout 변경 or 원복
            <para>OS 시간 변경으로 연결 종료 방지</para>
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.Tcp4.Clean">
            <summary>
            In buffer clear
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.Tcp4.Close">
            <summary>
            <para>close socket</para>
            <para>Exception이 없다, 내부적으로 모두 처리함.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.Tcp4.DefSckOpt(System.Net.Sockets.TcpClient)">
            <summary>
            tcp socket option 설정
            <para>NoDelay, LingerState, ReceiveTimeout</para>
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.Tcp4.Ignore(System.Int32)">
            <summary>
            읽어서 버림.
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.Tcp4.Init">
            <summary>
            Client의 경우 Comm.Retry 회수 만큼 연결 시도후 함수 return 됨.
            <para>BigEndian default</para>
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.Tcp4.KeepAlive(System.Single,System.Single)">
            <summary>
            KeepAlive 시도, 별도의 heart-beat 메시지 필요없음
            <para>OS parameter 가 아닌 값 세팅 가능</para>
            <para>idle 시간 동안 packet 수신이 없을 경우 자동 송신</para>
            <para>-</para>
            <para>초단위 데이터 대략 30정도 세팅 권장</para>
            <para>interval 만큼 10회정도 시도</para>
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.Tcp4.Read(System.Int32)">
            <summary>
            size만큼 읽어 MemoryBuffer에 담고 Pos를 0으로 이동한다.
            <para>-</para>
            <para>TimeoutException catch 가능함</para>
            <para>MaxBufSize 적용한 IOException 발생</para>
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.Tcp4.ReadInt(System.Int32,System.Boolean)">
            <summary>
            Int 변환
            <para>LittleEndian property 를 이용하여 ByteOrder세팅이 가능함.</para>
            <para>기본 양수만 반환</para>
            <para>양,음수 지원을 위한 signed 설정</para>
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.Tcp4.ReadTo(System.Byte)">
            <summary>
            <para>ETX 까지 읽는 경우.</para>
            <para>etx 는 포함되지 않음</para>
            <para>in stream 에서 etx 까지 읽음</para>
            <para>-</para>
            <para>TimeoutException catch 가능함</para>
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.Tcp4.Send(System.IO.Stream)">
            <summary>
            source 데이터 Tcp 에 write
            <para>Read 사용불가, Stream 의 끝을 잘 모름</para>
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.Tcp4.Send(GSG.NET.Utils.MemoryBuffer)">
            <summary>
            MemoryBuffer Position 관계 없이 모든 데이터 write
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.Tcp4.Send(System.Byte[])">
            <summary />
        </member>
        <member name="M:GSG.NET.TCP.Tcp4.Send(System.Int32)">
            <summary>
            int 4 byte send
            <para>LittleEndian property flag 에 따라 자동 변환</para>
            <para>최대한 MemoryBuffer를 활용한 send 방식으로 구현하며 사용 최소화</para>
            </summary>
        </member>
        <member name="T:GSG.NET.TCP.TcpComm">
            <summary>
            <para>T2: 30</para>
            <para>T6: 10</para>
            </summary>
        </member>
        <member name="P:GSG.NET.TCP.TcpComm.Active">
            <summary>
            def: true, client mode
            </summary>
        </member>
        <member name="P:GSG.NET.TCP.TcpComm.Ip">
            <summary/>
        </member>
        <member name="P:GSG.NET.TCP.TcpComm.PortNo">
            <summary/>
        </member>
        <member name="P:GSG.NET.TCP.TcpComm.RollCnt">
            <summary>
            <para>def: 1, not rolling</para>
            </summary>
        </member>
        <member name="P:GSG.NET.TCP.TcpComm.RetryCnt">
            <summary>
            def: int.MaxValue
            </summary>
        </member>
        <member name="P:GSG.NET.TCP.TcpComm.T2">
            <summary>
            연결 요청 시간
            <para>second</para>
            <para>def: 30</para>
            <para>-</para>
            <para>Lan2개 무선 AP의 경우 10초 이상 경우를 보정하기위해 30초 기본값</para>
            </summary>
        </member>
        <member name="P:GSG.NET.TCP.TcpComm.T5">
            <summary>
            second
            <para>연결시도 후 다음 연결시 까지 쉬는 시간</para>
            <para>def: 5</para>
            </summary>
        </member>
        <member name="P:GSG.NET.TCP.TcpComm.T6">
            <summary>
            socket timeout
            <para>연결후 socket read timeout 설정 시간</para>
            <para>-</para>
            <para>def: 10 second</para>
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.TcpComm.#ctor">
            <summary/>
        </member>
        <member name="P:GSG.NET.TCP.TcpComm.Ipe">
            <summary>
            ip, port를 기준으로 IPEndPoint 가져옴.
            </summary>
        </member>
        <member name="T:GSG.NET.TCP.TcpConnector">
            <summary>
            <para>Tcp 연결</para>
            <para>Tcp Access</para>
            <para>-</para>
            </summary>
        </member>
        <member name="E:GSG.NET.TCP.TcpConnector.OnTcpStateChanged">
            <summary>
            <para>Tcp 수행 Log</para>
            </summary>
        </member>
        <member name="P:GSG.NET.TCP.TcpConnector.Port">
            <summary>
            tcp port
            </summary>
        </member>
        <member name="P:GSG.NET.TCP.TcpConnector.IpAddress">
            <summary>
            tcp ip
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.Connect(GSG.NET.TCP.TcpComm)">
            <summary>
            TcpComm 객체를 이용한 연결.
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.WriteBeInt(System.Int32)">
            <summary>
            <para>Write Big Endian Int32</para>
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.WriteAscii(System.String)">
            <summary>
            <para>Write string data</para>
            <para>Encoding.ASCII</para>
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.WriteAscii(System.String,System.Text.Encoding)">
            <summary>
            <para>write string data</para>
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.WriteFlush(System.Byte[])">
            <summary>
            <para>write and flush one time</para>
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.WriteFlush(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <para>write and flush one time</para>
            </summary>
            <param name="bs"></param>
            <param name="offset">시작점</param>
            <param name="size"></param>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.CleanIn">
            <summary>
            In buffer clear
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.Read1Byte">
            <summary>
            1 바이트를 읽는다. int로 받는다.
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.ReadByte">
            <summary>
            1 바이트를 읽는다. byte로 받는다.
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.ReadBytes(System.Int32)">
            <summary>
            blocking read
            </summary>
            <param name="size">byte size</param>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.ReadBuf(System.Int32)">
            <summary>
            ReadBytes+MemoryBuffer + PosChange(0)
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.ReadUntil(System.Byte)">
            <summary>
            <para>NewLine, ETX까지 읽는 경우.</para>
            <para>b는 포함되지 않음</para>
            <para>in stream에서 b 까지 읽음</para>
            <para>-</para>
            <para>ReadLine의 경우 0x0d(\r), 0x0a(\n)</para>
            <para>Encoding.ASCII</para>
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.ReadUntilAscii(System.Byte)">
            <summary>
            <para>NewLine, ETX까지 읽는 경우.</para>
            <para>b는 포함되지 않음</para>
            <para>1. in stream에서 b 까지 읽음</para>
            <para>2. 0x00 -> 0x20</para>
            <para>3. Encoding.ASCII string으로 추출함</para>
            <para>-</para>
            <para>ReadLine의 경우 0x0d(\r), 0x0a(\n)</para>
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.ReadAscii(System.Int32)">
            <summary>
            <para>blocking read</para>
            <para>0x00 -> 0x20</para>
            <para>byte array를 Encoding.ASCII을 통해 string 변환</para>
            </summary>
            <param name="size">byte size</param>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.ReadAscii(System.Int32,System.Text.Encoding)">
            <summary>
            <para>blocking read</para>
            <para>0x00 -> 0x20</para>
            <para>byte array를 Encoding.GetString을 통해 string 변환</para>
            </summary>
            <param name="size">byte size</param>
            <param name="encoding">ascii encoding</param>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.ReadLeUshort">
            <summary>
            <para>little endian read 2 byte ushort</para>
            <para>1 0</para>
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.ReadLeShort">
            <summary>
            little endian read 2 byte short
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.ReadLeInt">
            <summary>
            little endian read 4 byte int
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.ReadBeShort">
            <summary>
            big endian read 2 byte short
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.ReadBeUshort">
            <summary>
            big endian read 2 byte ushort
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.ReadBeInt">
            <summary>
            Read 0 0 0 1 Big endian 4 byte integer
            </summary>
        </member>
        <member name="P:GSG.NET.TCP.TcpConnector.IPClient">
            <summary>
            ip, port를 기준으로 IPEndPoint 가져옴.
            </summary>
        </member>
        <member name="P:GSG.NET.TCP.TcpConnector.EpRemote">
            <summary>
            <para>TryListen일 경우 접속정보.</para>
            </summary>
        </member>
        <member name="P:GSG.NET.TCP.TcpConnector.Connected">
            <summary>
            tcp connect or not
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.StopListen">
            <summary>
            <para>연결이 완료되면 자동 stop listen을 하므로</para>
            <para>이 메소드는 listening중에 listen을 멈추게 하는 동작이다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.TryToListen">
            <summary>
            <para>server socket listen</para>
            <para>OnTcpStateChanged로 state 추적 가능</para>
            <para>TcpConnector는 연결하나에 대해 read, write를 하기 때문에</para>
            <para>연결이 되면 Listen 동작을 stop한다.</para>
            </summary>
        </member>
        <member name="P:GSG.NET.TCP.TcpConnector.Socket">
            <summary>
            Connected Socket object
            </summary>
        </member>
        <member name="P:GSG.NET.TCP.TcpConnector.Available">
            <summary/>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.TryToConnect(System.Int32)">
            <summary>
            Tcp connect
            </summary>
            <param name="sleep_ms">connect fail sleep milli-second interval</param>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.TryToConnect(System.Int32,System.Int32)">
            <summary>
            sync connect
            </summary>
            <param name="retryCount">connect retry count</param>
            <param name="sleep_ms">connect fail sleep milli-second interval</param>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.SetTcpClient(System.Net.Sockets.TcpClient)">
            <summary>
            NoDelayBinaryStream를 호출한 다음에 연결여부 Connected를 체크할수 있다.
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.TryOneConnect">
            <summary>
            <para>HsmsManager의 T5처리 connection logging처리를 위해 추가됨.</para>
            <para>한번만 Try하며 OnTcpStateChanged를 통해 수행 동작을 Logging이 가능하다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.TryOnceConnectUntilTimeout(System.Int32)">
            <summary>
            <para>Timeout 시간만 연결 한번 시도.</para>
            <para>-</para>
            <para>연결 여부는 Connected로 체크한다.</para>
            <para>-</para>
            <para>연결 성공: 50ms이내로 연결이 완료된다.</para>
            <para>-</para>
            <para>연결실패</para>
            <para>Case1</para>
            <para>IpAddress 찾기 성공했지만 Listen을 하고있지 않는 경우</para>
            <para>1초 정도 시간이 걸리며 conn_timeout을 10초로 세팅한 경우에도 1-2초 후에 연결실패처리를 한다.</para>
            <para>-</para>
            <para>Case2</para>
            <para>IpAddress 찾기 실패</para>
            <para>conn_timeout만큼 시도를 하고 연결실패 처리를 한다.</para>
            </summary>
            <param name="timeout">millisecond</param>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.ChangeRecvTimeout(System.Int32)">
            <summary>
            <para>change socket receive timeout</para>
            </summary>
            <param name="ms">milli-second</param>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.ChangeTimeout(System.Int32)">
            <summary>
            Change send, recd timeout both
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.TcpConnector.CloseSocket">
            <summary>
            <para>close socket</para>
            <para>Exception이 없다, 내부적으로 모두 처리함.</para>
            </summary>
        </member>
        <member name="T:GSG.NET.TCP.TcpUtils">
            <summary>
            
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.TcpUtils.GetTcpErrMsg(System.Exception)">
            <summary>
            <para>IOException: Message</para>
            <para>SocketException: WSAE and InnerException Message</para>
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.TcpUtils.GetTcpErrMsg(System.Net.EndPoint,System.Exception)">
            <summary>
            <para>IOException: Message</para>
            <para>SocketException: WSAE and InnerException Message</para>
            </summary>
        </member>
        <member name="M:GSG.NET.TCP.TcpUtils.MakeWsaeMsg(System.String,System.Net.Sockets.SocketException)">
            <summary>
            WSAE: Windows Socket Application Exception
            </summary>
        </member>
        <member name="T:GSG.NET.Utils.AppUtils">
            <summary/>
        </member>
        <member name="P:GSG.NET.Utils.AppUtils.DevSvcMode">
            <summary>
            service develop(debug) mode check
            <para>Environment.UserInteractive</para>
            </summary>
        </member>
        <member name="P:GSG.NET.Utils.AppUtils.DevMode">
            <summary>
            develop(debug) mode check
            <para>Debugger.IsAttached</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.AppUtils.LogGlobalException">
            <summary>
            Logging UI, UnhandledException.
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.AppUtils.IsFindWindow(System.String)">
            <summary/>
        </member>
        <member name="M:GSG.NET.Utils.AppUtils.ShowWindow(System.String)">
            <summary/>
        </member>
        <member name="M:GSG.NET.Utils.AppUtils.HideWindow(System.String)">
            <summary/>
        </member>
        <member name="M:GSG.NET.Utils.AppUtils.SendCloseMessageByTitle(System.String)">
            <summary>
            <para>Title을 이용한 종료.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.AppUtils.SendCloseMessage(System.IntPtr)">
            <summary>
            <para>Handle을 이용한 종료.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.AppUtils.SendCloseMessage(System.String)">
            <summary>
            <para>ProcessName을 이용한 종료 .exe는 생략해야함.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.AppUtils.DisableCloseButton(System.Windows.Forms.Form)">
            <summary/>
        </member>
        <member name="T:GSG.NET.Utils.AssemblyUtils">
            <summary>
            Assembly reflection utils class
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.AssemblyUtils.ReadEmbedded(System.Reflection.Assembly,System.String,System.Text.Encoding)">
            <summary>
            Assembly의 Embedded resource읽어오기
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.AssemblyUtils.EmbedResRead(System.Reflection.Assembly,System.String,System.Text.Encoding)">
            <summary>
            Assembly의 Embedded resource읽어오기
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.AssemblyUtils.EmbedResCopy(System.Reflection.Assembly,System.String,System.String)">
            <summary>
            Embed resource copy to some file
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.AssemblyUtils.BuildDate(System.Reflection.Assembly)">
            <summary/>
        </member>
        <member name="M:GSG.NET.Utils.AssemblyUtils.BuildDate(System.Type)">
            <summary/>
        </member>
        <member name="M:GSG.NET.Utils.AssemblyUtils.IsNullableType(System.Type)">
            <summary>
            Nullable or not
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.AssemblyUtils.IsPublicProperty(System.Type,System.String)">
            <summary>
            public property or not
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.AssemblyUtils.IsPublicMethod(System.Type,System.String)">
            <summary>
            public method or not
            </summary>
        </member>
        <member name="P:GSG.NET.Utils.AssemblyUtils.FlowareVersion">
            <summary>
            get Floware version info.
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.AssemblyUtils.GetVersion">
            <summary>
            <para>호출자의 Version 정보 display</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.AssemblyUtils.GetVersion(System.Object)">
            <summary>
            get version some assembly or class
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.AssemblyUtils.GetDescription(System.Object)">
            <summary>
            get description assembly
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.AssemblyUtils.ToString(System.Object,System.String[])">
            <summary>
            <para>SPACE ToString utils.</para>
            <para>ClassName, Propertys</para>
            </summary>
            <param name="me">this</param>
            <param name="ignores">case sensitive, asterix(*) support</param>
        </member>
        <member name="M:GSG.NET.Utils.AssemblyUtils.ToNewLineString(System.Object,System.String[])">
            <summary>
            <para>NEWLINE ToString utils.</para>
            <para>ClassName, Propertys</para>
            </summary>
            <param name="me">this</param>
            <param name="ignores">case sensitive, asterix(*) support</param>
        </member>
        <member name="M:GSG.NET.Utils.AssemblyUtils.PropValue(System.Object,System.String)">
            <summary>
            
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.AssemblyUtils.GetPropsPublic(System.Type)">
            <summary>
            <para>public property array</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.AssemblyUtils.GetProps(System.Type)">
            <summary>
            <para>Public, NonPublic property array</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.AssemblyUtils.GetChgdProp(System.Object,System.Object)">
            <summary>
            src, dest의 값이 변한 값들 추출하는 함수.
            </summary>
            <param name="src"></param>
            <param name="dest"></param>
            <returns>PropName, DestValue dictionary</returns>
        </member>
        <member name="M:GSG.NET.Utils.AssemblyUtils.GetClsName(System.Object)">
            <summary/>
        </member>
        <member name="M:GSG.NET.Utils.AssemblyUtils.GetClsFullName(System.Object)">
            <summary/>
        </member>
        <member name="M:GSG.NET.Utils.AssemblyUtils.GetConstName(System.Type,System.Object)">
            <summary>
            <para>const value를 이용하여 const name을 추출함.</para>
            <para>읽기 쉬운 name을 추출함.</para>
            <para>Public const만 추출 가능함.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.AssemblyUtils.Invoke(System.Object,System.String,System.Object[])">
            <summary>
            <para>public method reflection invoke</para>
            </summary>
        </member>
        <member name="T:GSG.NET.Utils.Assert">
            <summary>
            <para>Assert Class</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.Assert.AreEqual(System.Object,System.Object,System.String,System.Object[])">
            <summary>
            <para>objA와 objB는 Equals로 비교할 경우 True이어야 함.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.Assert.AreNotEqual(System.Object,System.Object,System.String,System.Object[])">
            <summary>
            <para>objA와 objB는 Equals로 비교할 경우 False이어야 함.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.Assert.NotNull(System.Object,System.String,System.Object[])">
            <summary>
            <para>null이면 안됨</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.Assert.IsNull(System.Object,System.String,System.Object[])">
            <summary>
            <para>반드시 null 이어야 함.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.Assert.IsFalse(System.Boolean,System.String,System.Object[])">
            <summary>
            <para>반드시 false이어야 함</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.Assert.IsTrue(System.Boolean,System.String,System.Object[])">
            <summary>
            <para>반드시 true이어야 함.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.Assert.Fail(System.String,System.Object[])">
            <summary>
            <para>fail처리</para>
            </summary>
        </member>
        <member name="T:GSG.NET.Utils.AssertException">
            <summary>
            GSG.NET. Assert처리를 위한 AssertException
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.AssertException.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.AssertException.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:GSG.NET.Utils.BitUtils">
            <summary>
            <para>ReplaceNullToSpace(byte[] bs)</para>
            <para>ReplaceNonAsciiToSpace(byte[] bs)</para>
            <para>byte[] ChangeBitArray(int intV)</para>
            <para>ChgBitString</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.BitUtils.ReplaceNullToSpace(System.Byte[])">
            <summary>
            0x00 -> 0x20
            </summary>
            <param name="bs"></param>
        </member>
        <member name="M:GSG.NET.Utils.BitUtils.ReplaceNonAsciiToSpace(System.Byte[])">
            <summary>
            ascii code !(0x20 ~ 0x7f) -> 0x20
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.BitUtils.ChgString(System.Int32,System.Int32)">
            <summary>
            int -> bit string
            <para>length padright or substring</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.BitUtils.ChgString(System.Int32)">
            <summary>
            int -> bit string
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.BitUtils.ChgInt32(System.String)">
            <summary>
            bit string -> int
            <para>e.g. 00000000000000000000000000000011 -> 3</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.BitUtils.ChgBytes(System.Int32)">
            <summary>
            <para>int -> byte array</para>
            <para>e.g. 3 -> 00000000000000000000000000000011</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.BitUtils.ChgBytes(System.Int16)">
            <summary>
            <para>int -> byte array</para>
            <para>e.g. 3 -> 0000000000000011</para>        
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.BitUtils.ChgBytes(System.Collections.BitArray)">
            <summary>
            BitArray -> byte array
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.BitUtils.ChgBitArray(System.Int32)">
            <summary>
            int -> BitArray(32)
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.BitUtils.ChgBitArray(System.Byte[])">
            <summary>
            Byte array -> BitArray
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.BitUtils.ChgInt32(System.Collections.BitArray)">
            <summary>
            BitArray to int
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.BitUtils.Enlarge8(System.Byte[])">
            <summary>
            <para>arg bytes를 bit format으로 8배 확장하여 byte array 구성</para>
            </summary>
        </member>
        <member name="T:GSG.NET.Utils.CharsetUtils">
            <summary>
            Ascii &lt;-&gt; byte[]
            </summary>
        </member>
        <member name="F:GSG.NET.Utils.CharsetUtils.CODE_PAGE_KOREAN">
            <summary/>
        </member>
        <member name="F:GSG.NET.Utils.CharsetUtils.CODE_PAGE_EUC_KR">
            <summary/>
        </member>
        <member name="F:GSG.NET.Utils.CharsetUtils.CODE_PAGE_ISO_8859_1">
            <summary>
            western european
            </summary>
        </member>
        <member name="F:GSG.NET.Utils.CharsetUtils.CODE_PAGE_UTF8">
            <summary/>
        </member>
        <member name="F:GSG.NET.Utils.CharsetUtils.CODE_PAGE_UTF16">
            <summary/>
        </member>
        <member name="F:GSG.NET.Utils.CharsetUtils.CODE_PAGE_SHIFT_JIS">
            <summary/>
        </member>
        <member name="F:GSG.NET.Utils.CharsetUtils.CODE_PAGE_CHINESE_1">
            <summary>
            중국어 간체(GB2312)"
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.CharsetUtils.Change(System.String)">
            <summary>
            <para>string -> byte[]</para>
            <para>Gets an encoding for the ASCII (7-bit) character set.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.CharsetUtils.Change(System.String,System.Text.Encoding)">
            <summary>
            <para>string -> byte[]</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.CharsetUtils.Change(System.String,System.Int32)">
            <summary>
            Encode Code를 이용한 변경
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.CharsetUtils.Change(System.Byte[])">
            <summary>
            <para>byte[] -> string</para>
            <para>Gets string for the ASCII (7-bit) character set.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.CharsetUtils.Change(System.Byte[],System.Text.Encoding)">
            <summary>
            <para>Ascii이므로 0x00 -> 0x20 기능 포함.</para>
            <para>byte[] -> string</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.CharsetUtils.Change(System.Byte[],System.Int32)">
            <summary>
            Encode Code를 이용한 변경
            </summary>
        </member>
        <member name="T:GSG.NET.Utils.ChksumUtils">
            <summary/>
        </member>
        <member name="F:GSG.NET.Utils.ChksumUtils.POLY_16_IBM">
            <summary/>
        </member>
        <member name="M:GSG.NET.Utils.ChksumUtils.Crc16IBM(System.UInt16[],System.Int32,System.Byte[])">
            <summary>
            <para>CRC16 IBM.</para>
            <para>Polynomial: x^16 + x^15 + x^2 + 1 (0xa001)</para>
            <para>-</para>
            <para>Modbus Crc16</para>
            <para>GenTable(POLY_16_IBM)</para>
            <para>initCrcV(0xffff)</para>
            </summary>
            <param name="table"></param>
            <param name="initCrcV"></param>
            <param name="bs"></param>
        </member>
        <member name="M:GSG.NET.Utils.ChksumUtils.Crc8(System.Byte[],System.Byte[])">
            <summary>
            <para>CRC8 = 0xd5, CRC8_CCITT = 0x07, CRC8_DALLAS_MAXIM = 0x31, CRC8_SAE_J1850 = 0x1D, CRC_8_WCDMA = 0x9b,</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.ChksumUtils.Crc8GenTable(System.Int32)">
            <summary>
            x8 + x7 + x6 + x4 + x2 + 1
            const byte poly = 0xd5;
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.ChksumUtils.Crc16GenTable(System.Int32)">
            <summary>
            <para>CRC16 IBM:Polynomial: x^16 + x^15 + x^2 + 1 (0xa001)</para>
            </summary>
            <param name="poly"></param>
        </member>
        <member name="T:GSG.NET.Utils.ConstUtils">
            <summary>
            Floware const data
            </summary>
        </member>
        <member name="F:GSG.NET.Utils.ConstUtils.ONE_KILO_BYTES">
            <summary>
            1024
            </summary>
        </member>
        <member name="F:GSG.NET.Utils.ConstUtils.ONE_MEGA_BYTES">
            <summary>
            1024 * ONE_KILO_BYTES;
            </summary>
        </member>
        <member name="F:GSG.NET.Utils.ConstUtils.ONE_GIGA_BYTES">
            <summary>
            1024 * ONE_MEGA_BYTES;
            </summary>
        </member>
        <member name="F:GSG.NET.Utils.ConstUtils.ONE_SECOND">
            <summary>
            1000 ms
            </summary>
        </member>
        <member name="F:GSG.NET.Utils.ConstUtils.ONE_MINUTE">
            <summary>
            60 * ONE_SECOND;
            </summary>
        </member>
        <member name="F:GSG.NET.Utils.ConstUtils.ONE_HOUR">
            <summary>
            60 * ONE_MINUTE;
            </summary>
        </member>
        <member name="F:GSG.NET.Utils.ConstUtils.ONE_DAY">
            <summary>
            24 * ONE_HOUR;
            </summary>
        </member>
        <member name="F:GSG.NET.Utils.ConstUtils.ONE_WEEK">
            <summary>
            7 * ONE_DAY;
            </summary>
        </member>
        <member name="F:GSG.NET.Utils.ConstUtils.SPACE_CHAR">
            <summary>
            ' ';
            </summary>
        </member>
        <member name="F:GSG.NET.Utils.ConstUtils.ESC">
            <summary>
            escape string
            </summary>
        </member>
        <member name="F:GSG.NET.Utils.ConstUtils.DIR_CHAR">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSG.NET.Utils.ConstUtils.DIR">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSG.NET.Utils.ConstUtils.SPACE">
            <summary>
            " ";
            </summary>
        </member>
        <member name="F:GSG.NET.Utils.ConstUtils.QUOTATION">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSG.NET.Utils.ConstUtils.QUOTATION_SINGLE">
            <summary>
            
            </summary>
        </member>
        <member name="F:GSG.NET.Utils.ConstUtils.SPACE20">
            <summary>
            "                    ";
            </summary>
        </member>
        <member name="F:GSG.NET.Utils.ConstUtils.SPACE25">
            <summary>
            "                         ";
            </summary>
        </member>
        <member name="F:GSG.NET.Utils.ConstUtils.IP_LOCAL_HOST">
            <summary>
            <para>127.0.0.1</para>
            </summary>
        </member>
        <member name="F:GSG.NET.Utils.ConstUtils.HTML_TAB">
            <summary/>
        </member>
        <member name="F:GSG.NET.Utils.ConstUtils.HTML_SPACE">
            <summary/>
        </member>
        <member name="T:GSG.NET.Utils.DateUtils">
            <summary>
            각종 Begin, End함수 구현
            <para>TimeChange 함수</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.DateUtils.Quarter(System.DateTime)">
            <summary/>
        </member>
        <member name="M:GSG.NET.Utils.DateUtils.BeginOfMonth(System.Int32,System.Int32)">
            <summary>
            월초
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.DateUtils.BeginOfYear(System.Int32)">
            <summary>
            년초
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.DateUtils.BeginOfWeek(System.Int32,System.Int32)">
            <summary>
            Week Number를 이용한 DateTime 가져오기
            <para>1주 시작 Sunday 기준</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.DateUtils.BeginOfWeek(System.DateTime)">
            <summary>
            <para>1주 시작 일~토 기준</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.DateUtils.EndOfWeek(System.DateTime)">
            <summary>
            <para>1주끝 일~토 기준</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.DateUtils.EndOfWeek(System.Int32,System.Int32)">
            <summary>
            Week를 이용한 DateTime 가져오기
            <para>12월말일 경우에 다음년도의 날짜 초반을 가져온다. (향후 변경 가능성 있음)</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.DateUtils.BeginOfQuarter(System.Int32,System.Int32)">
            <summary/>
        </member>
        <member name="M:GSG.NET.Utils.DateUtils.EndOfYear(System.Int32)">
            <summary>
            년말
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.DateUtils.EndOfQuarter(System.Int32,System.Int32)">
            <summary>
            <para>날짜 계산과 시간을 23:59:59로 계산하여 가져온다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.DateUtils.EndOfMonth(System.Int32,System.Int32)">
            <summary>
            Month 마지막 날 자동 계산
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.DateUtils.EndOfDay(System.DateTime)">
            <summary/>
        </member>
        <member name="M:GSG.NET.Utils.DateUtils.ChangeSystemTime(System.String)">
            <summary>
            PC 시간 변경.
            <para>14자리. yyyyMMddHHmmss</para>
            </summary>
        </member>
        <member name="P:GSG.NET.Utils.DateUtils.CurrentTimeMillis">
            <summary/>
        </member>
        <member name="M:GSG.NET.Utils.DateUtils.ToTimeMillis(System.DateTime)">
            <summary>
            may be also new TimeSpan(DateTime.UtcNow.Ticks).TotalMilliseconds;
            http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dv_jlca/html/vberrjavalangsystemcurrenttimemillis.asp
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.DateUtils.ToString(System.DateTime)">
            <summary>
            <para>yyyy-MMdd HH:mm:ss.fff</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.DateUtils.ToString(System.DateTime,System.String)">
            <summary>
            <para>Invariant Culture Format</para>
            <para>dt.ToString(format, System.Globalization.DateTimeFormatInfo.InvariantInfo)</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.DateUtils.WeekNumber(System.DateTime)">
            <summary>
            arg의 DateTime이 몇번째 Week인지 가져오기
            <para>해가 바뀌는 부분을 감안하여 일요일 기준으로 WeekNumber를 계산한다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.DateUtils.DayCount(System.DateTime)">
            <summary>
            DateTime의 day가 몇일인지 가져오기.
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.DateUtils.Parse(System.String)">
            <summary>
            <para>Parse가 실패할 경우 1년,1월,1일 반환.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.DateUtils.Parse(System.String,System.String)">
            <summary>
            <para>Parse가 실패할 경우 1년,1월,1일 반환.</para>
            <para>format을 이용한 parse</para>
            </summary>
        </member>
        <member name="T:GSG.NET.Utils.DelegateUtils">
            <summary>
            <para>DelegateUtils</para>
            <para>Change UI Thread</para>
            <para>Method용 Invoke 지원</para>
            <para>Delegate용 Invoke 지원</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.DelegateUtils.IsControlInstance(System.Delegate)">
            <summary>
            <para>Delegate를 이용한 호출 메소드가 Control 즉 화면인지 여부</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.DelegateUtils.IsWPFControlInstance(System.Delegate)">
            <summary>
            Delegate 에 Target 이 WPF control 인지 확인한다.
            </summary>
            <param name="dlg"></param>
            <returns></returns>
        </member>
        <member name="M:GSG.NET.Utils.DelegateUtils.GetControlTarget(System.Delegate)">
            <summary>
            <para>Delegate의 Target을 가져옴.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.DelegateUtils.GetWPFControlTarget(System.Delegate)">
            <summary>
            WPF Control 을 가져옴.
            </summary>
            <param name="dlg"></param>
            <returns></returns>
        </member>
        <member name="M:GSG.NET.Utils.DelegateUtils.ChgCtrlText(System.Windows.Forms.Control,System.Object)">
            <summary>
            <para>Cross-thread 처리 완료.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.DelegateUtils.Invoke(System.Action)">
            <summary>
            <para>BeginInvoke를 이용해서 화면 스레드로 변환함</para>
            <para>호출 method는 void 0 argument가 없어야 함.</para>
            <para>-</para>
            <para>Exception 내부 처리 및 로깅</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.DelegateUtils.Invoke``1(System.Action{``0},``0)">
            <summary>
            <para>BeginInvoke를 이용해서 화면 스레드로 변환함</para>
            <para>-</para>
            <para>호출 method는 void 1 argument.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.DelegateUtils.Invoke``2(System.Action{``0,``1},``0,``1)">
            <summary>
            <para>BeginInvoke를 이용해서 화면 스레드로 변환함</para>
            <para>-</para>
            <para>호출 method는 void 2 argument.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.DelegateUtils.Invoke``3(System.Action{``0,``1,``2},``0,``1,``2)">
            <summary>
            <para>BeginInvoke를 이용해서 화면 스레드로 변환함</para>
            <para>-</para>
            <para>호출 method는 void 3 argument.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.DelegateUtils.Invoke``4(System.Action{``0,``1,``2,``3},``0,``1,``2,``3)">
            <summary>
            <para>BeginInvoke를 이용해서 화면 스레드로 변환함</para>
            <para>-</para>
            <para>호출 method는 void 4 argument.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.DelegateUtils.Call(System.Delegate,System.Object[])">
            <summary>
            <para>단순 호출, 화면 Thread등을 고려하지 않는다.</para>
            <para>Exception이 발생함</para>
            <para>Exception 미 처리시 CallEx 사용</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.DelegateUtils.CallEx(System.Delegate,System.Object[])">
            <summary>
            
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.DelegateUtils.Invoke(System.Delegate,System.Object[])">
            <summary>
            <para>delegate용 Thread change Invoke</para>
            </summary>
            <param name="dlg">Event입력</param>
            <param name="args"></param>
        </member>
        <member name="M:GSG.NET.Utils.DelegateUtils.RaiseEventAsync(System.Delegate,System.Object[])">
            <summary>
            Test 필요.
            <para>delegate용 Thread change Invoke</para>
            </summary>
            <param name="handler">Event입력</param>
            <param name="args"></param>
        </member>
        <member name="T:GSG.NET.Utils.HexaUtils">
            <summary>
            <para>byte를 string으로 변환함.</para>
            </summary>
        </member>
        <member name="F:GSG.NET.Utils.HexaUtils.map1">
            <summary>
            string key를 이용해 byte를 찾기위함. (성능향상을 위해 구현함)
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.HexaUtils.StringToByte(System.String)">
            <summary>
            "01" -> 1 byte
            "FF" -> 0xff byte
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.HexaUtils.ToString(System.Byte[])">
            <summary>
            hexspace를 이용하며 delimeter를 space로 처리함.
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.HexaUtils.ToString(System.Byte[],System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.HexaUtils.ToFF(System.Byte[])">
            <summary>
            <para>FF format으로 붙인다</para>
            <para>space가 없으며 DB blob 저장시 유용함.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.HexaUtils.FromFF(System.String)">
            <summary>
            <para>HexaString -> byte array</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.HexaUtils.Hex2StringSpace(System.Byte)">
            <summary>
            "00 ", "01 ", "02 ", "03 "...
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.HexaUtils.Hex2String(System.Byte)">
            <summary>
            "00", "01", "02", "03"...
            </summary>
        </member>
        <member name="T:GSG.NET.Utils.IniUtils">
            <summary>
            Win32 ini
            </summary>
        </member>
        <member name="F:GSG.NET.Utils.IniUtils.MAX_SECTION_SIZE">
            <summary>
            The maximum size of a section in an ini file.
            </summary>
            <remarks>
            This property defines the maximum size of the buffers 
            used to retreive data from an ini file.  This value is 
            the maximum allowed by the win32 functions 
            GetPrivateProfileSectionNames() or 
            GetPrivateProfileString().
            </remarks>
        </member>
        <member name="P:GSG.NET.Utils.IniUtils.FileName">
            <summary>
            <para>없으면 파일을 만드므로 File Exist Check하지 않는다.</para>
            </summary>
        </member>
        <member name="T:GSG.NET.Utils.IniUtils.NativeMethods">
            <summary>
            A static class that provides the win32 P/Invoke signatures 
            used by this class.
            </summary>
            <remarks>
            Note:  In each of the declarations below, we explicitly set CharSet to 
            Auto.  By default in C#, CharSet is set to Ansi, which reduces 
            performance on windows 2000 and above due to needing to convert strings
            from Unicode (the native format for all .Net strings) to Ansi before 
            marshalling.  Using Auto lets the marshaller select the Unicode version of 
            these functions when available.
            </remarks>
        </member>
        <member name="M:GSG.NET.Utils.IniUtils.GetString(System.String,System.String,System.String)">
            <summary>
            Gets the value of a setting in an ini file as a <see cref="T:System.String"/>.
            </summary>
            <param name="sectionName">The name of the section to read from.</param>
            <param name="keyName">The name of the key in section to read.</param>
            <param name="defaultValue">The default value to return if the key
            cannot be found.</param>
            <returns>The value of the key, if found.  Otherwise, returns 
            <paramref name="defaultValue"/></returns>
            <remarks>
            The retreived value must be less than 512KB in length.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="sectionName"/> or <paramref name="keyName"/> are 
            a null reference  (Nothing in VB)
            </exception>
        </member>
        <member name="M:GSG.NET.Utils.IniUtils.GetInt16(System.String,System.String,System.Int16)">
            <summary>
            Gets the value of a setting in an ini file as a <see cref="T:System.Int16"/>.
            </summary>
            <param name="sectionName">The name of the section to read from.</param>
            <param name="keyName">The name of the key in section to read.</param>
            <param name="defaultValue">The default value to return if the key
            cannot be found.</param>
            <returns>The value of the key, if found.  Otherwise, returns 
            <paramref name="defaultValue"/>.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="sectionName"/> or <paramref name="keyName"/> are 
            a null reference  (Nothing in VB)
            </exception>
        </member>
        <member name="M:GSG.NET.Utils.IniUtils.GetInt32(System.String,System.String,System.Int32)">
            <summary>
            Gets the value of a setting in an ini file as a <see cref="T:System.Int32"/>.
            </summary>
            <param name="sectionName">The name of the section to read from.</param>
            <param name="keyName">The name of the key in section to read.</param>
            <param name="defaultValue">The default value to return if the key
            cannot be found.</param>
            <returns>The value of the key, if found.  Otherwise, returns 
            <paramref name="defaultValue"/></returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="sectionName"/> or <paramref name="keyName"/> are 
            a null reference  (Nothing in VB)
            </exception>
        </member>
        <member name="M:GSG.NET.Utils.IniUtils.GetDouble(System.String,System.String,System.Double)">
            <summary>
            Gets the value of a setting in an ini file as a <see cref="T:System.Double"/>.
            </summary>
            <param name="sectionName">The name of the section to read from.</param>
            <param name="keyName">The name of the key in section to read.</param>
            <param name="defaultValue">The default value to return if the key
            cannot be found.</param>
            <returns>The value of the key, if found.  Otherwise, returns 
            <paramref name="defaultValue"/></returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="sectionName"/> or <paramref name="keyName"/> are 
            a null reference  (Nothing in VB)
            </exception>
        </member>
        <member name="M:GSG.NET.Utils.IniUtils.GetSectionValuesAsList(System.String)">
            <summary>
            Gets all of the values in a section as a list.
            </summary>
            <param name="sectionName">
            Name of the section to retrieve values from.
            </param>
            <returns>
            A <see cref="T:System.Collections.Generic.List`1"/> containing <see cref="T:System.Collections.Generic.KeyValuePair`2"/> objects 
            that describe this section.  Use this verison if a section may contain
            multiple items with the same key value.  If you know that a section 
            cannot contain multiple values with the same key name or you don't 
            care about the duplicates, use the more convenient 
            <see cref="M:GSG.NET.Utils.IniUtils.GetSectionValues(System.String)"/> function.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="sectionName"/> is a null reference  (Nothing in VB)
            </exception>
        </member>
        <member name="M:GSG.NET.Utils.IniUtils.GetSectionValues(System.String)">
            <summary>
            Gets all of the values in a section as a dictionary.
            </summary>
            <param name="sectionName">
            Name of the section to retrieve values from.
            </param>
            <returns>
            A <see cref="T:System.Collections.Generic.Dictionary`2"/> containing the key/value 
            pairs found in this section.  
            </returns>
            <remarks>
            If a section contains more than one key with the same name, 
            this function only returns the first instance.  If you need to 
            get all key/value pairs within a section even when keys have the 
            same name, use <see cref="M:GSG.NET.Utils.IniUtils.GetSectionValuesAsList(System.String)"/>.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="sectionName"/> is a null reference  (Nothing in VB)
            </exception>
        </member>
        <member name="M:GSG.NET.Utils.IniUtils.GetKeyNames(System.String)">
            <summary>
            Gets the names of all keys under a specific section in the ini file.
            </summary>
            <param name="sectionName">
            The name of the section to read key names from.
            </param>
            <returns>An array of key names.</returns>
            <remarks>
            The total length of all key names in the section must be 
            less than 512KB in length.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="sectionName"/> is a null reference  (Nothing in VB)
            </exception>
        </member>
        <member name="M:GSG.NET.Utils.IniUtils.GetSectionNames">
            <summary>
            
            </summary>
        </member>
        <member name="P:GSG.NET.Utils.IniUtils.AllSectionNames">
            <summary>
            Gets the names of all sections in the ini file.
            </summary>
            <returns>An array of section names.</returns>
            <remarks>
            The total length of all section names in the section must be 
            less than 512KB in length.
            </remarks>
        </member>
        <member name="M:GSG.NET.Utils.IniUtils.ConvertNullSeperatedStringToStringArray(System.IntPtr,System.Int32)">
            <summary>
            Converts the null seperated pointer to a string into a string array.
            </summary>
            <param name="ptr">A pointer to string data.</param>
            <param name="valLength">
            Length of the data pointed to by <paramref name="ptr"/>.
            </param>
            <returns>
            An array of strings; one for each null found in the array of characters pointed
            at by <paramref name="ptr"/>.
            </returns>
        </member>
        <member name="M:GSG.NET.Utils.IniUtils.WriteValueInternal(System.String,System.String,System.String)">
            <summary>
            Writes a <see cref="T:System.String"/> value to the ini file.
            </summary>
            <param name="sectionName">The name of the section to write to .</param>
            <param name="keyName">The name of the key to write to.</param>
            <param name="value">The string value to write</param>
            <exception cref="T:System.ComponentModel.Win32Exception">
            The write failed.
            </exception>
        </member>
        <member name="M:GSG.NET.Utils.IniUtils.WriteValue(System.String,System.String,System.String)">
            <summary>
            Writes a <see cref="T:System.String"/> value to the ini file.
            </summary>
            <param name="sectionName">The name of the section to write to .</param>
            <param name="keyName">The name of the key to write to.</param>
            <param name="value">The string value to write</param>
            <exception cref="T:System.ComponentModel.Win32Exception">
            The write failed.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="sectionName"/> or <paramref name="keyName"/> or 
            <paramref name="value"/>  are a null reference  (Nothing in VB)
            </exception>
        </member>
        <member name="M:GSG.NET.Utils.IniUtils.WriteValue(System.String,System.String,System.Int16)">
            <summary>
            Writes an <see cref="T:System.Int16"/> value to the ini file.
            </summary>
            <param name="sectionName">The name of the section to write to .</param>
            <param name="keyName">The name of the key to write to.</param>
            <param name="value">The value to write</param>
            <exception cref="T:System.ComponentModel.Win32Exception">
            The write failed.
            </exception>
        </member>
        <member name="M:GSG.NET.Utils.IniUtils.WriteValue(System.String,System.String,System.Int32)">
            <summary>
            Writes an <see cref="T:System.Int32"/> value to the ini file.
            </summary>
            <param name="sectionName">The name of the section to write to .</param>
            <param name="keyName">The name of the key to write to.</param>
            <param name="value">The value to write</param>
            <exception cref="T:System.ComponentModel.Win32Exception">
            The write failed.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="sectionName"/> or <paramref name="keyName"/> are 
            a null reference  (Nothing in VB)
            </exception>
        </member>
        <member name="M:GSG.NET.Utils.IniUtils.WriteValue(System.String,System.String,System.Single)">
            <summary>
            Writes an <see cref="T:System.Single"/> value to the ini file.
            </summary>
            <param name="sectionName">The name of the section to write to .</param>
            <param name="keyName">The name of the key to write to.</param>
            <param name="value">The value to write</param>
            <exception cref="T:System.ComponentModel.Win32Exception">
            The write failed.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="sectionName"/> or <paramref name="keyName"/> are 
            a null reference  (Nothing in VB)
            </exception>
        </member>
        <member name="M:GSG.NET.Utils.IniUtils.WriteValue(System.String,System.String,System.Double)">
            <summary>
            Writes an <see cref="T:System.Double"/> value to the ini file.
            </summary>
            <param name="sectionName">The name of the section to write to .</param>
            <param name="keyName">The name of the key to write to.</param>
            <param name="value">The value to write</param>
            <exception cref="T:System.ComponentModel.Win32Exception">
            The write failed.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="sectionName"/> or <paramref name="keyName"/> are 
            a null reference  (Nothing in VB)
            </exception>
        </member>
        <member name="M:GSG.NET.Utils.IniUtils.DeleteKey(System.String,System.String)">
            <summary>
            Deletes the specified key from the specified section.
            </summary>
            <param name="sectionName">
            Name of the section to remove the key from.
            </param>
            <param name="keyName">
            Name of the key to remove.
            </param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="sectionName"/> or <paramref name="keyName"/> are 
            a null reference  (Nothing in VB)
            </exception>
        </member>
        <member name="M:GSG.NET.Utils.IniUtils.DeleteSection(System.String)">
            <summary>
            Deletes a section from the ini file.
            </summary>
            <param name="sectionName">
            Name of the section to delete.
            </param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="sectionName"/> is a null reference (Nothing in VB)
            </exception>
        </member>
        <member name="T:GSG.NET.Utils.MemoryBuffer">
            <summary>
            <para>memory stream buffer, default size 256</para>
            <para>Append와 Read함수 지원함</para>
            <para>.net이 little endian이 기본이므로</para>
            <para>Little endian은 byte swap을 하지 않고 Big endian은 byte swap을 하고 값을 읽고쓴다</para>
            <para></para>
            <para>Append</para>
            <para>MemoryBuffer에 데이터를 추가하는 함수</para>
            <para>최종 ToBytes를 이용하여 한번에 byte array를 추출함.</para>
            <para></para>
            <para>Read</para>
            <para>mb.Append(byte[])를 하고</para>
            <para>ResetSeek()를 이용하여 position초기화</para>
            <para>ReadLexxx 등을 사용하여 position을 자동 이동시키며</para>
            <para>byte array에서 int, short등을 추출한다.</para>
            <para>-</para>
            <para>201603:Append의 return값을 제거함, Length와 Pos가 불명확함.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.#ctor">
            <summary>
            기본 size:256으로 할당한다
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.#ctor(System.Int32)">
            <summary>
            bufSize 만큼 buffer를 할당한다
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.#ctor(System.Byte[])">
            <summary>
            1. buffer를 입력된 bs 만큼 할당한다
            <para>2. Append를 내부적으로 호출하여 bs를 append한다</para>
            <para>3. Position을 최초로 이동하여 바로 ReadXXX를 사용가능하게 한다</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.Reset">
            <summary>
            <para>MemoryBuffer를 초기화하고(데이터 삭제됨)</para> 
            <para>새로운 MemoryStream을 생성함.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.Append(System.Byte[])">
            <summary>
            bs -> MemoryBuffer
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.PosChange(System.Int32)">
            <summary>
            <para>Change curr position</para>
            <para>Multi thread에서는 Lock처리가 필요함.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.PosShift(System.Int32)">
            <summary>
            <para>Shift left or right</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.ResetSeek">
            <summary>
            <para>MemoryBuffer position을 처음으로 복귀시킴.</para>
            <para>Pos '0'</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.PosBegin">
            <summary>
            Position을 제일 앞으로
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.PosEnd">
            <summary>
            Position을 제일 마지막으로
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.PeekBytes(System.Int32,System.Int32)">
            <summary>
            Position 이동을 하지 않는다.
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.Append(System.Int32)">
            <summary>
            <para>integer를 byte를 casting하여 append함수 호출</para>
            </summary>
            <param name="i">0~255</param>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.Fill(System.Int32,System.Byte)">
            <summary>
            length만큼 b 로 채워서 Append함.
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.Append(GSG.NET.Utils.MemoryBuffer)">
            <summary>
            from의 데이터를 this memory buffer를 합친다.
            <para>from의 Position에 관계없이 from의 모든 데이터를 this에 추가한다.</para>
            <para>this의 position은 유효함.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.Append(System.Byte[],System.Int32)">
            <summary>
            bs -> MemoryBuffer
            </summary>
            <param name="bs"></param>
            <param name="offset">From bs offset to end</param>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.Append(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <para>bs -> MemoryBuffer</para>
            <para>length를 둔 이유는 넘치거나 적은 데이터의 보정을 위함.</para>
            <para>bs가 length를 넘치거나 적은 경우 대비한 로직.</para>
            </summary>
            <param name="bs"></param>
            <param name="offset">bs의 시작점</param>
            <param name="size">offset부터 append 할 byte size</param>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.Chg(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <para>MemoryBuffer 값변경.</para>
            <para>offset은 bs의 시작점.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.Chg(System.Byte)">
            <summary>
            현재위치(pos)의 1 byte 값만 변경함
            <para>성능향상 용도</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.Chg(System.Int32,System.Byte[])">
            <summary>
            <para>MemoryBuffer 값변경.</para>
            <para>pos 부터 bs로 변경하고 원래 Position으로 반환한다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.AppendLeUint(System.UInt32)">
            <summary>
            little endian
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.AppendLeInt(System.Int32)">
            <summary>
            little endian
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.AppendLeInt3(System.Int32)">
            <summary>
            3byte int 처리.
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.AppendLeShort(System.Int32)">
            <summary>
            Append little endian short
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.AppendLeShort(System.Int16)">
            <summary>
            little endian
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.AppendLeUshort(System.Int32)">
            <summary>
            little endian
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.AppendLeUshort(System.UInt16)">
            <summary>
            little endian
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.AppendLeFloat(System.Single)">
            <summary>
            Little endian 4 byte float value append.
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.AppendBeFloat(System.Single)">
            <summary>
            Big endian 4 byte float value append
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.AppendBeDouble(System.Double)">
            <summary>
            Big endian 8 byte double value append
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.AppendAscii(System.String)">
            <summary>
            <para>Append string</para>
            <para>Encoding.ASCII</para>
            <para>영문, 한글 및 unicode도 1byte로 치환된다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.AppendAscii(System.String,System.Text.Encoding)">
            <summary>
            <para>Append string</para>
            <para>Encoding에 따른 byte수가 다를 수 있다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.AppendAscii(System.Int32,System.String)">
            <summary>
            <para>Ascii Length 보정.</para>
            <para>0x00->0x20</para>
            <para>Encoding.ASCII</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.AppendAscii(System.Int32,System.String,System.Text.Encoding)">
            <summary>
            <para>Ascii Length 보정.</para>
            <para>0x00->0x20</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.AppendAscii(System.Int32,System.String,System.Int32)">
            <summary>
            <para>Ascii Length 보정.</para>
            <para>0x00->0x20</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.AppendAscii0x00(System.Int32,System.String)">
            <summary>
            <para>Ascii Length 보정 0x00으로 나머지를 채운다.</para>
            <para>영문, 한글 및 unicode도 1byte로 치환된다.</para>
            <para>Encoding.ASCII</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.AppendAscii0x00(System.Int32,System.String,System.Text.Encoding)">
            <summary>
            <para>Ascii Length 보정 0x00으로 나머지를 채운다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.AppendBeShort(System.Int32)">
            <summary>
            big endian
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.AppendBeUshort(System.Int32)">
            <summary>
            big endian
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.AppendBeShort(System.Int16)">
            <summary>
            big endian
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.AppendBeInt(System.Int32)">
            <summary>
            big endian
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.AppendBeInt3(System.Int32)">
            <summary>
            3byte int 처리.
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.AppendBeUint(System.UInt32)">
            <summary>
            big endian
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.AppendBeUint(System.Int64)">
            <summary>
            big endian
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.AppendBeLong(System.Int64)">
            <summary>
            big endian
            </summary>
        </member>
        <member name="P:GSG.NET.Utils.MemoryBuffer.ToBytes">
            <summary>
            <para>전체를 byte array로 추출</para>
            </summary>
        </member>
        <member name="P:GSG.NET.Utils.MemoryBuffer.ToAscii">
            <summary>
            <para>전체를 string으로 추출</para>
            </summary>
        </member>
        <member name="P:GSG.NET.Utils.MemoryBuffer.ToHex">
            <summary>
            <para>space, hexa string</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.ToHexLine(System.Int32)">
            <summary>
            lineDigit byte를 기준으로 NewLine처리
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.ReadLeInt">
            <summary>
            <para>Memory buffer에서 4byte를 읽어서 little endian 을 만든다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.ReadLeInt3">
            <summary>
            3byte int 처리.
            <para>최상위 바이트 0을 뒤에 추가하여 Int로 처리함.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.ReadBitArray(System.Int32)">
            <summary>
            size 만큼 읽어서 BitArray 작성
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.ReadAscii(System.Int32)">
            <summary>
            <para>size 만큼 읽어서 string 변환, null(0x00)문자가 있으면 space로 치환한다.</para>
            <para>byte[] bs = ReadBytes(size);</para>
            <para>Encoding.ASCII</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.ReadAscii(System.Int32,System.Text.Encoding)">
            <summary>
            <para>size 만큼 읽어서 string 변환, null(0x00)문자가 있으면 space로 치환한다.</para>
            <para>byte[] bs = ReadBytes(size);</para>
            <para>Encoding에 의해 string으로 변환한다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.ReadAscT(System.Int32)">
            <summary>
            Read Ascii Trim with Encoding.Default
            <para>Encoding은 Encoding.Default를 사용한다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.ReadBeInt">
            <summary>
            <para>Memory buffer에서 4byte를 읽어서 big endian 을 만든다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.ReadBeInt3">
            <summary>
            3byte int 처리.
            <para>최상위 바이트 0을 앞에 추가하여 Int로 처리함.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.ReadBeUint">
            <summary>
            <para>Memory buffer에서 4byte를 읽어서 big endian 을 만든다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.ReadBeFloat">
            <summary>
            <para>Memory buffer에서 4byte를 읽어서 big endian 을 만든다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.ReadBeDouble">
            <summary>
            <para>Memory buffer에서 8byte를 읽어서 big endian 을 만든다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.ReadBeLong">
            <summary>
            <para>Memory buffer에서 8byte를 읽어서 big endian 을 만든다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.ReadBeUshort">
            <summary>
            <para>Memory buffer에서 2byte를 big endian으로 읽는다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.ReadBeShort">
            <summary>
            <para>Memory buffer에서 2byte를 big endian으로 읽는다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.ReadLeUshort">
            <summary>
            <para>Memory buffer에서 2byte를 little endian으로 읽는다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.ReadLeShort">
            <summary>
            <para>Memory buffer에서 2byte를 little endian으로 읽는다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.ReadLeFloat">
            <summary>
            <para>Memory buffer에서 4byte를 little endian</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.ReadLeDouble">
            <summary>
            <para>Memory buffer에서 8byte를 little endian</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.Read1Byte">
            <summary>
            1 바이트를 읽는다. int로 받는다.
            <para>0~255(0~0xff)</para>
            <para>int.Equals(byte)는 값이 같으면 True가 되지만</para>
            <para>byte.Equals(int)는 값이 같아도 False가 된다.</para>
            <para>byte == int, int == byte 는 값이 같을 경우 True가 되므로 Equals 보다 == 사용 권장.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.ReadByte">
            <summary>
            <para>1 바이트를 읽는다. byte로 받는다.</para>
            <para>int.Equals(byte)는 값이 같으면 True가 되지만</para>
            <para>byte.Equals(int)는 값이 같아도 False가 된다.</para>
            <para>byte == int, int == byte 는 값이 같을 경우 True가 되므로 Equals 보다 == 사용 권장.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.ReadBytes(System.Int32)">
            <summary>
            <para>Memorybuffer에서 byte추출</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.MemoryBuffer.ReadBytesRest">
            <summary>
            현재 pos의 나머지 읽기
            </summary>
        </member>
        <member name="P:GSG.NET.Utils.MemoryBuffer.Pos">
            <summary>
            MemoryBuffer access position
            </summary>
        </member>
        <member name="P:GSG.NET.Utils.MemoryBuffer.Length">
            <summary>
            실제 valid(append 되었던) Size
            <para>Position이 이동되어도 Length는 기존 값을 유지한다.</para>
            </summary>
        </member>
        <member name="T:GSG.NET.Utils.NumUtils">
            <summary>
            
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.NumUtils.Random(System.Int32,System.Int32)">
            <summary>
            <para>1~10 까지 수행하려면 Random(1, 10)</para>
            <para>바로 이전에 구한값과 중복은 발생하지 않게 처리함.</para>
            <para>ThreadStatic을 적용하여 Thread마다 각각 이전 값을 유지함.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.NumUtils.Ceiling(System.Int32,System.Int32)">
            <summary>
            <para>올림</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.NumUtils.Floor(System.Int32,System.Int32)">
            <summary>
            <para>내림</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.NumUtils.Round(System.Int32,System.Int32)">
            <summary>
            <para>반올림</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.NumUtils.IsMultiple(System.Int32,System.Int32)">
            <summary>
            <para>배수인지 체크</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.NumUtils.IsOddNumber(System.Int32)">
            <summary>
            홀수인지 체크
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.NumUtils.Remainder(System.Int32,System.Int32)">
            <summary>
            <para>나머지 구하기</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.NumUtils.RangeCheck(System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>Range check</para>
            <para>e.g. RangeCheck(i, 0, short.MaxValue)</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.NumUtils.RangeCheck(System.Double,System.Double,System.Double)">
            <summary/>
        </member>
        <member name="M:GSG.NET.Utils.NumUtils.Percent(System.Object,System.Object)">
            <summary>
            <para>백분율 가져오기</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.NumUtils.IsNumber(System.Object)">
            <summary>
            <para>obj의 Type이 Integer or decimal인지 여부 검사.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.NumUtils.CanConvertToInteger(System.String)">
            <summary>
            <para>argument를 integer로 변경 가능한지?</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.NumUtils.Average(System.Int32[])">
            <summary>
            <para>평균 구하기</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.NumUtils.Average(System.Double[])">
            <summary>
            <para>평균 구하기</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.NumUtils.Variance(System.Double[])">
            <summary>
            <para>분포도(분산)</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.NumUtils.StdDev(System.Double[])">
            <summary>
            <para>표준편차</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.NumUtils.Median(System.Double[])">
            <summary>
            중간값.
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.NumUtils.Min(System.Int32[])">
            <summary>
            <para>최소값</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.NumUtils.Min(System.Double[])">
            <summary>
            <para>최소값</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.NumUtils.Max(System.Int32[])">
            <summary>
            <para>최대값</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.NumUtils.Max(System.Double[])">
            <summary>
            <para>최대값</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.NumUtils.IntV(System.String)">
            <summary>
            string.Empty일 경우 0 반환
            <para>TryParse가 실패할 경우 0반환</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.NumUtils.IntHexV(System.String)">
            <summary>
            string.Empty일 경우 0 반환
            <para>TryParse가 실패할 경우 0반환</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.NumUtils.DoubleV(System.String)">
            <summary>
            string.Empty일 경우 0 반환
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.NumUtils.FloatV(System.String)">
            <summary/>
        </member>
        <member name="T:GSG.NET.Utils.ObjectCopyUtils">
            <summary>
            Deep Copy 지원
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.ObjectCopyUtils.DeepClone``1(``0)">
            <summary>
             Deep Clone 구현
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:GSG.NET.Utils.ObjectCopyUtils.SerializableDeepClone``1(``0)">
            <summary>
            Serializable 객체에 대한  Deep Clone
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:GSG.NET.Utils.ProcessUtils">
            <summary>
            AddStartUpProcess는 windows registry를 사용하며 실행 폴더는 system folder가 되므로
            spring config, log4net config를 상대 경로 가능 수정(2012.07)
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.ProcessUtils.AddStartUpProcess(System.String,System.String,System.Object[])">
            <summary/>
        </member>
        <member name="M:GSG.NET.Utils.ProcessUtils.RemoveStartUpProcess(System.String)">
            <summary>
            <para>Remove StartUp Process</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.ProcessUtils.AddMeStartUpProcess(System.Object[])">
            <summary>
            <para>Add Current Process StartUp</para>
            </summary>
        </member>
        <member name="P:GSG.NET.Utils.ProcessUtils.IsAutoStartMe">
            <summary>
            현재 Process가 AutoStart에 등록되어 있는지?
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.ProcessUtils.RemoveMeStartUpProcess">
            <summary>
            <para>Remove Current Process StartUp</para>
            </summary>
        </member>
        <member name="P:GSG.NET.Utils.ProcessUtils.IsOnlyOneInstance">
            <summary>
            <para>프로세스 이름을 이용하여 OnlyOneInstance check를 한다.</para>
            </summary>
        </member>
        <member name="P:GSG.NET.Utils.ProcessUtils.CurrentProcessName">
            <summary>
            <para>Get Current Process Name</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.ProcessUtils.GetProcess(System.String)">
            <summary>
            <para>Process Name을 이용해 Process 개체를 가져옴</para>
            <para>여러개일 경우 첫번째 Process만 가져옴</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.ProcessUtils.GetProcesses(System.String)">
            <summary>
            <para>Process Name을 이용해 Process Array를 가져옴.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.ProcessUtils.GetProcessCount(System.String)">
            <summary>
            <para>Get Excuted Process Count</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.ProcessUtils.Kill(System.String)">
            <summary>
            <para>Process Name으로 Process Kill</para>
            <para>xxx.exe -> processName: xxx</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.ProcessUtils.KillGraceful(System.String)">
            <summary>
            <para>Form Close에 로직이 있는 경우에 사용함.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.ProcessUtils.Start(System.String)">
            <summary>
            <para>App 실행</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.ProcessUtils.Start(System.String,System.String)">
            <summary>
            <para>App 실행, argument 입력</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.ProcessUtils.Start(System.String,System.String,System.String)">
            <summary>
            <para>App 실행</para>
            </summary>
            <param name="path"></param>
            <param name="wd">Working Directory</param>
            <param name="args"></param>
        </member>
        <member name="M:GSG.NET.Utils.ProcessUtils.StartWaitForExit(System.String,System.String,System.String)">
            <summary>
            <para>실행한 process가 종료될때까지 block됨.</para>
            </summary>
            <param name="path"></param>
            <param name="wd">Working directory, null or empty 입력 가능</param>
            <param name="args">null or empty 가능</param>
        </member>
        <member name="M:GSG.NET.Utils.ProcessUtils.StartConsoleRedirect(System.String,System.String,System.String)">
            <summary>
            <para>Console process를 실행하고 결과를 redirect하여 string으로 받는다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.ProcessUtils.Kill(System.Int32)">
            <summary>
            <para>processID가 없을 경우에도 Exception이 발생하지 않는다, return 값으로 체크</para>
            </summary>
            <param name="processID"></param>
            <returns>Killed or Not</returns>
        </member>
        <member name="T:GSG.NET.Utils.StringUtils">
            <summary>
            GSG.NET..Utils.StringUtils
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.StringUtils.ToString(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            dictionary를 key=value 형태로 만듦
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.StringUtils.Int2Bit(System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.StringUtils.Byte2Bit(System.Byte)">
            <summary>
            Convert.ToString(v, 2);
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.StringUtils.Substring(System.String,System.String,System.String)">
            <summary>
            
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.StringUtils.HasTwoParams(System.String,System.String,System.String)">
            <summary>
            org에 From, To 가 모두 존재하는지 검사함.
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.StringUtils.QuietSubstring(System.String,System.String,System.String)">
            <summary>
            Ignore error
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.StringUtils.SubstringAfter(System.String,System.String)">
            <summary>
            
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.StringUtils.QuietSubstringAfter(System.String,System.String)">
            <summary>
            Ignore error
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.StringUtils.SubstringBefore(System.String,System.String)">
            <summary>
            Ignore error
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.StringUtils.QuietSubstringBefore(System.String,System.String)">
            <summary>
            
            </summary>
        </member>
        <member name="T:GSG.NET.Utils.SwUtils">
            <summary>
            <para>Stopwatch: elapsed time check</para>
            </summary>
        </member>
        <member name="P:GSG.NET.Utils.SwUtils.T">
            <summary>
            <para>same CurrentTimeMillis</para>
            </summary>
        </member>
        <member name="P:GSG.NET.Utils.SwUtils.CurrentTimeMillis">
            <summary>
            <para>CurrentTime의 millisecond 가져옴</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.SwUtils.ElapsedTime(System.Int64)">
            <summary>
            <para>string.Format("[{0:d3} ms]", gap);</para>
            <para>Use F</para>
            </summary>
            <param name="pre">이전 milli-second</param>
        </member>
        <member name="M:GSG.NET.Utils.SwUtils.F(System.Int64)">
            <summary>
            <para>string.Format("[{0:d3} ms]", gap);</para>
            <para>Use F</para>
            </summary>
            <param name="pre">이전 milli-second</param>
        </member>
        <member name="M:GSG.NET.Utils.SwUtils.Elapsed(System.Int64)">
            <summary/>
        </member>
        <member name="M:GSG.NET.Utils.SwUtils.Gt(System.Int64,System.Int32)">
            <summary/>
        </member>
        <member name="T:GSG.NET.Utils.SznUtils">
            <summary/>
        </member>
        <member name="M:GSG.NET.Utils.SznUtils.CanSerialize(System.Object)">
            <summary>
            <para>Serializable 가능 여부 체크</para>
            </summary>
        </member>
        <member name="M:GSG.NET.Utils.SznUtils.Serialize(System.Object)">
            <summary/>
        </member>
        <member name="M:GSG.NET.Utils.SznUtils.Deserialize(System.Byte[])">
            <summary/>
        </member>
        <member name="T:GSG.NET.Utils.MidnightNotifier">
            <summary>
            날짜가 바뀜을 알려준다.
            </summary>
        </member>
        <member name="T:GSG.NET.Utils.FixTimeNotifier">
            <summary>
            정시를 알려줌
            </summary>
        </member>
        <member name="T:GSG.NET.V2.SerialV2">
            <summary>
            Serial 통신 Ver2
            </summary>
        </member>
        <member name="P:GSG.NET.V2.SerialV2.H">
            <summary/>
        </member>
        <member name="P:GSG.NET.V2.SerialV2.Name">
            <summary>
            SerialV2 구분자
            <para>구별을 위해서는 Name을 적절히 변경한다.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.V2.SerialV2.#ctor">
            <summary>
            ReadWrite Timeout def 2 sec
            </summary>
        </member>
        <member name="M:GSG.NET.V2.SerialV2.Init">
            <summary>
            open serial port
            </summary>
        </member>
        <member name="M:GSG.NET.V2.SerialV2.Send(System.Byte[])">
            <summary/>
        </member>
        <member name="M:GSG.NET.V2.SerialV2.Send(GSG.NET.Utils.MemoryBuffer)">
            <summary/>
        </member>
        <member name="M:GSG.NET.V2.SerialV2.Read(System.Int32)">
            <summary>
            <para>blocking read</para>
            </summary>
        </member>
        <member name="M:GSG.NET.V2.SerialV2.ReadTo(System.Byte)">
            <summary>
            <para>NewLine, ETX까지 읽는 경우.</para>
            <para>b는 포함되지 않음</para>
            <para>in stream에서 b 까지 읽음</para>
            </summary>
        </member>
        <member name="M:GSG.NET.V2.SerialV2.Ignore(System.Int32)">
            <summary>
            읽어서 버림.
            </summary>
        </member>
        <member name="M:GSG.NET.V2.SerialV2.Close">
            <summary>
            close SerailPort
            </summary>
        </member>
        <member name="M:GSG.NET.V2.SerialV2.Clean">
            <summary>
            Clean buffer
            </summary>
        </member>
        <member name="M:GSG.NET.V2.SerialV2.ToString">
            <summary/>
        </member>
        <member name="T:GSG.NET.V2.SignalV2">
            <summary>
            Local Multicast 통신
            <para>netsh int ip show joins</para>
            </summary>
        </member>
        <member name="P:GSG.NET.V2.SignalV2.Charset">
            <summary>
            string 통신 encoding 설정
            </summary>
        </member>
        <member name="M:GSG.NET.V2.SignalV2.#ctor">
            <summary/>
        </member>
        <member name="P:GSG.NET.V2.SignalV2.Channel">
            <summary>
            Channel을 통한 수신
            </summary>
        </member>
        <member name="E:GSG.NET.V2.SignalV2.OnMessage">
            <summary>
            arg1: cmd
            <para>arg2: value</para>
            </summary>
        </member>
        <member name="M:GSG.NET.V2.SignalV2.Init">
            <summary/>
        </member>
        <member name="M:GSG.NET.V2.SignalV2.OpenMulticast">
            <summary>
            Server: IpAddr을 세팅하지 않음
            <para>Client: IpAddr setting</para>
            </summary>
        </member>
        <member name="M:GSG.NET.V2.SignalV2.Send(System.Object,System.String,System.Object[])">
            <summary>
            <para>cmd: 구분자</para>
            <para>-</para>
            <para>format 또는 value를 넣어도 호환됨.</para>
            <para>format : {0,-10}{1,-20}{2} 등등</para>
            <para>string.format을 쉽게 사용함</para>
            </summary>
        </member>
        <member name="M:GSG.NET.V2.SignalV2.Send(System.Object,System.String)">
            <summary>
            <para>cmd: 구분자</para>
            <para>cmd는 int, string, enum 허용함</para>
            <para>-</para>
            <para>string value only</para>
            </summary>
        </member>
        <member name="M:GSG.NET.V2.SignalV2.Send(System.Object,System.Object)">
            <summary>
            <para>cmd는 int, string, enum 허용함</para>
            <para>obj value는 int, enum 및 ToString을이용하는 항목과, serialize object 허용</para>
            </summary>
        </member>
        <member name="M:GSG.NET.V2.SignalV2.ThSend">
            <summary>
            Length(4)+guid(1+n)+channel(1+n)+cmd(1+n)+protocol(1)+value or object(n)
            </summary>
        </member>
        <member name="F:GSG.NET.V2.SignalV2.MAX_UDP_SIZE">
            <summary>
            4 KB
            </summary>
        </member>
        <member name="F:GSG.NET.V2.SignalV2.MAX_DATA_SIZE">
            <summary>
            Max 2 MB
            </summary>
        </member>
        <member name="M:GSG.NET.V2.SignalV2.Read(System.Int32)">
            <summary>
            size 읽을때까지 blocking
            <para>size -1, clear garbage buffer</para>
            </summary>
        </member>
        <member name="T:GSG.NET.V2.SignalV2.InMsg">
            <summary/>
        </member>
        <member name="P:GSG.NET.V2.SignalV2.InMsg.Guid">
            <summary/>
        </member>
        <member name="P:GSG.NET.V2.SignalV2.InMsg.Length">
            <summary/>
        </member>
        <member name="P:GSG.NET.V2.SignalV2.InMsg.Cmd">
            <summary/>
        </member>
        <member name="P:GSG.NET.V2.SignalV2.InMsg.Value">
            <summary>
            string value
            </summary>
        </member>
        <member name="P:GSG.NET.V2.SignalV2.InMsg.Serialize">
            <summary>
            객체통신
            </summary>
        </member>
        <member name="T:GSG.NET.V2.TcpV2">
            <summary>
            <para>2016.06.15 최초 개발</para>
            <para>default: BigEndian</para>
            </summary>
        </member>
        <member name="P:GSG.NET.V2.TcpV2.LittleEndian">
            <summary>
            default: false, 즉 BigEndian default
            </summary>
        </member>
        <member name="P:GSG.NET.V2.TcpV2.Comm">
            <summary/>
        </member>
        <member name="M:GSG.NET.V2.TcpV2.#ctor">
            <summary/>
        </member>
        <member name="M:GSG.NET.V2.TcpV2.Init">
            <summary>
            Client의 경우 Comm.Retry 회수 만큼 연결 시도후 함수 return 됨.
            </summary>
        </member>
        <member name="P:GSG.NET.V2.TcpV2.Sck">
            <summary/>
        </member>
        <member name="P:GSG.NET.V2.TcpV2.KeepAlive">
            <summary/>
        </member>
        <member name="M:GSG.NET.V2.TcpV2.DefSckOpt(System.Net.Sockets.TcpClient)">
            <summary>
            tcp socket option 설정
            <para>NoDelay, LingerState, ReceiveTimeout</para>
            </summary>
        </member>
        <member name="M:GSG.NET.V2.TcpV2.Close">
            <summary>
            <para>close socket</para>
            <para>Exception이 없다, 내부적으로 모두 처리함.</para>
            </summary>
        </member>
        <member name="M:GSG.NET.V2.TcpV2.Clean">
            <summary>
            In buffer clear
            </summary>
        </member>
        <member name="M:GSG.NET.V2.TcpV2.Ignore(System.Int32)">
            <summary>
            읽어서 버림.
            </summary>
        </member>
        <member name="M:GSG.NET.V2.TcpV2.ReadInt(System.Int32)">
            <summary>
            Int변환
            <para>LittleEndian property를 이용하여 ByteOrder세팅이 가능함.</para>
            <para>size 2일 경우 Ushort 변환</para>
            <para>-</para>
            <para>TimeoutException catch 가능함</para>
            </summary>
        </member>
        <member name="M:GSG.NET.V2.TcpV2.Read(System.Int32)">
            <summary>
            size만큼 읽어 MemoryBuffer에 담고 Pos를 0으로 이동한다.
            <para>-</para>
            <para>TimeoutException catch 가능함</para>
            </summary>
        </member>
        <member name="M:GSG.NET.V2.TcpV2.ReadTo(System.Byte)">
            <summary>
            <para>ETX까지 읽는 경우.</para>
            <para>b는 포함되지 않음</para>
            <para>in stream에서 b 까지 읽음</para>
            <para>-</para>
            <para>TimeoutException catch 가능함</para>
            </summary>
        </member>
        <member name="P:GSG.NET.V2.TcpV2.Connected">
            <summary>
            tcp connect or not
            <para>Sck == null이면 false</para>
            </summary>
        </member>
        <member name="M:GSG.NET.V2.TcpV2.Send(GSG.NET.Utils.MemoryBuffer)">
            <summary>
            MemoryBuffer Position 관계 없이 모든 데이터 write
            </summary>
        </member>
        <member name="M:GSG.NET.V2.TcpV2.Send(System.Byte[])">
            <summary/>
        </member>
        <member name="M:GSG.NET.V2.TcpV2.Send(System.Int32)">
            <summary>
            int 4 byte send
            <para>LittleEndian property flag에 따라 자동 변환</para>
            <para>최대한 MemoryBuffer를 활용한 send 방식으로 구현하며 사용 최소화</para>
            </summary>
        </member>
        <member name="M:GSG.NET.V2.TcpV2.ChgTimeout(System.Boolean)">
            <summary>
            T6 기준 infinite timeout 변경 or 원복
            <para>OS 시간 변경으로 연결 종료 방지</para>
            </summary>
        </member>
        <member name="T:GSG.NET.V2.UdpV2">
            <summary/>
        </member>
        <member name="P:GSG.NET.V2.UdpV2.IpAddr">
            <summary/>
        </member>
        <member name="P:GSG.NET.V2.UdpV2.PortNo">
            <summary/>
        </member>
        <member name="P:GSG.NET.V2.UdpV2.TTL">
            <summary>
            TTL: Microsoft def 128, Floware 8
            <para>TTL:0 Local Mode</para>
            </summary>
        </member>
        <member name="P:GSG.NET.V2.UdpV2.BufferSize">
            <summary>
            def : 10 mb
            </summary>
        </member>
        <member name="P:GSG.NET.V2.UdpV2.Sck">
            <summary/>
        </member>
        <member name="P:GSG.NET.V2.UdpV2.Timeout">
            <summary>
            Receive timeout
            </summary>
        </member>
        <member name="M:GSG.NET.V2.UdpV2.#ctor">
            <summary/>
        </member>
        <member name="M:GSG.NET.V2.UdpV2.Init(System.Boolean)">
            <summary>
            Server: IpAddr을 세팅하지 않음
            <para>Client: IpAddr setting</para>
            </summary>
        </member>
        <member name="M:GSG.NET.V2.UdpV2.Send(GSG.NET.Utils.MemoryBuffer)">
            <summary/>
        </member>
        <member name="M:GSG.NET.V2.UdpV2.Reply(GSG.NET.Utils.MemoryBuffer)">
            <summary>
            수신된 연결로 reply 보냄
            </summary>
        </member>
        <member name="M:GSG.NET.V2.UdpV2.Clean">
            <summary>
            In buffer garbage clear
            </summary>
        </member>
        <member name="M:GSG.NET.V2.UdpV2.Read(System.Int32)">
            <summary>
            size 읽을때까지 blocking
            <para>size -1 경우, Clean과 동일함.</para>
            <para>Timeout일 경우 SocketTimeoutException이 발생</para>
            </summary>
        </member>
        <member name="M:GSG.NET.V2.UdpV2.Close">
            <summary/>
        </member>
        <member name="E:GSG.NET.V3.FourthCenter.OnMessage">
            <summary/>
        </member>
        <member name="P:GSG.NET.V3.FourthCenter.Charset">
            <summary>
            string 통신 encoding 설정
            </summary>
        </member>
        <member name="M:GSG.NET.V3.FourthCenter.#ctor">
            <summary/>
        </member>
        <member name="M:GSG.NET.V3.FourthCenter.Init(System.Int32)">
            <summary/>
        </member>
        <member name="M:GSG.NET.V3.FourthCenter.Reply(System.Net.IPEndPoint,System.Object[])">
            <summary/>
        </member>
        <member name="T:GSG.NET.V3.FourthCenter.Item">
            <summary/>
        </member>
        <member name="P:GSG.NET.V3.FourthCenter.Item.Origin">
            <summary>
            Origin value
            </summary>
        </member>
        <member name="P:GSG.NET.V3.FourthCenter.Item.StrV">
            <summary>
            string or enum value get
            </summary>
        </member>
        <member name="P:GSG.NET.V3.FourthCenter.Item.IntV">
            <summary/>
        </member>
        <member name="P:GSG.NET.V3.FourthCenter.Item.BoolV">
            <summary/>
        </member>
        <member name="M:GSG.NET.V3.FourthCenter.Item.ToString">
            <summary/>
        </member>
        <member name="T:GSG.NET.V3.SignalV3">
            <summary>
            Local Multicast 통신
            <para>PortNo 이용하여 그룹간 통신을 제한이 가능하다, 171101</para>
            <para>-</para>
            <para>상태: netsh int ip show joins</para>
            </summary>
        </member>
        <member name="P:GSG.NET.V3.SignalV3.Charset">
            <summary>
            string 통신 encoding 설정
            </summary>
        </member>
        <member name="P:GSG.NET.V3.SignalV3.PortNo">
            <summary>
            Def: 27545
            </summary>
        </member>
        <member name="M:GSG.NET.V3.SignalV3.#ctor">
            <summary/>
        </member>
        <member name="T:GSG.NET.V3.SignalV3.DlgMsg">
            <summary/>
        </member>
        <member name="E:GSG.NET.V3.SignalV3.OnMessage">
            <summary>
            arg1: length
            <para>arg2: values</para>
            </summary>
        </member>
        <member name="M:GSG.NET.V3.SignalV3.Init">
            <summary/>
        </member>
        <member name="M:GSG.NET.V3.SignalV3.OpenMulticast">
            <summary>
            Server: IpAddr을 세팅하지 않음
            <para>Client: IpAddr setting</para>
            </summary>
        </member>
        <member name="M:GSG.NET.V3.SignalV3.Send(System.Object[])">
            <summary>
            <para>여러타입을 하나의 메시지로 보낼수 있음.</para>
            <para>-</para>
            <para>지원타입</para>
            <para>string, int, bool, enum, byte[], serializable object</para>
            </summary>
        </member>
        <member name="M:GSG.NET.V3.SignalV3.SendAfter(System.Single,System.Object[])">
            <summary>
            지연후 send
            <para>0th: 초단위 timeout</para>
            <para>나머지 항목은 Send와 동일</para>
            <para>second 0보다 작거나 같을 경우 Send와 동일함</para>
            </summary>
        </member>
        <member name="M:GSG.NET.V3.SignalV3.Request(System.Single,System.Object[])">
            <summary>
            timeout이 발생하면 List count 0이 됨
            <para>0th: 초단위 timeout</para>
            </summary>
        </member>
        <member name="M:GSG.NET.V3.SignalV3.Reply(System.Collections.Generic.List{GSG.NET.V3.SignalV3.Item},System.Object[])">
            <summary/>
        </member>
        <member name="F:GSG.NET.V3.SignalV3.MAX_UDP_SIZE">
            <summary>
            4 KB
            </summary>
        </member>
        <member name="F:GSG.NET.V3.SignalV3.MAX_DATA_SIZE">
            <summary>
            Max 2 MB
            </summary>
        </member>
        <member name="T:GSG.NET.V3.SignalV3.Item">
            <summary/>
        </member>
        <member name="P:GSG.NET.V3.SignalV3.Item.Origin">
            <summary>
            Origin value
            </summary>
        </member>
        <member name="P:GSG.NET.V3.SignalV3.Item.StrV">
            <summary>
            string or enum value get
            </summary>
        </member>
        <member name="P:GSG.NET.V3.SignalV3.Item.IntV">
            <summary>
            IntType or EnumType's value
            </summary>
        </member>
        <member name="P:GSG.NET.V3.SignalV3.Item.FloatV">
            <summary/>
        </member>
        <member name="P:GSG.NET.V3.SignalV3.Item.BoolV">
            <summary/>
        </member>
        <member name="P:GSG.NET.V3.SignalV3.Item.IsEnum">
            <summary>
            EmumType or not
            </summary>
        </member>
        <member name="M:GSG.NET.V3.SignalV3.Item.ToString">
            <summary/>
        </member>
        <member name="M:GSG.NET.V3.SignalV3.Read(System.Int32)">
            <summary>
            size 읽을때까지 blocking
            <para>size -1, clear garbage buffer</para>
            </summary>
        </member>
    </members>
</doc>
